<!DOCTYPE html>

<html lang="fr" xml:lang="fr" xmlns="http://www.w3.org/1999/xhtml">
<head>
<script>
        window.MathJax = {
          tex: {
            tags: 'ams'
          }
        };
       </script>

<meta charset="utf-8"/>
<meta content="pandoc" name="generator"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport"/>
<meta content="S√©bastien Boisg√©rault, MINES ParisTech" name="author"/>
<title>Le mod√®le √©pid√©miologique SIR</title>
<style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
<link href="css/style.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&amp;display=swap" rel="stylesheet"/>
<script>

      function filterConsole(text) {
          let lines = text.split("\n");

          console.log(lines);

          let pythonConsole = lines && lines[0].startsWith(">>>");
          if (!pythonConsole) {
              return text + "\n\n";
          } else {
              let newLines = [];
              for (let line of lines) {
                  if (line.startsWith(">>> ") || line.startsWith("... ")) {
                      newLines.push(line.slice(4));
                  } else if (line.startsWith("...")){
                      newLines.push(line.slice(3));
                  }

              }
              return newLines.join("\n") + "\n";
          }

      }

      document.addEventListener("DOMContentLoaded", (event) => {
          let codeBlocks = document.querySelectorAll("pre.python")
          for (let codeBlock of codeBlocks) {

              let button = document.createElement("button")
              let icon = document.createElement("img");
              button.appendChild(icon)
              codeBlock.insertBefore(button, codeBlock.firstChild);

              icon.setAttribute("src", "icons/copy.svg");
              icon.setAttribute("style", "opacity: 0.5;")
              button.addEventListener('click', (event) => {
                  let text = button.nextElementSibling.textContent;
                  text = filterConsole(text);
                  navigator.clipboard.writeText(text);
              });

              codeBlock.setAttribute("style", "position: relative");
              button.setAttribute("style", 
              "position: absolute; right: 1em; top: 1em; opacity: 0.0;");

              codeBlock.addEventListener("mouseover", (event) => {
                  button.style.setProperty("transition", "opacity 0.1s ease-out");
                  button.style.setProperty("opacity", "1.0");
              });

              codeBlock.addEventListener("mouseout", (event) => {
                  button.style.setProperty("transition", "opacity 0.75s ease-out");
                  button.style.setProperty("opacity", "0.0");
              });

              button.addEventListener("mouseover", (event) => {
                  icon.style.setProperty("transition", "opacity 0.1s ease-out");
                  icon.style.setProperty("opacity", "0.75");
              })

              button.addEventListener("mouseout", (event) => {
                  icon.style.setProperty("transition", "opacity 0.75s ease-out");
                  icon.style.setProperty("opacity", "0.5");
              })


          }
      });    
  </script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
<!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Le mod√®le √©pid√©miologique SIR</h1>
<p class="author"><a href="mailto:Sebastien.Boisgerault@mines-paristech.fr">S√©bastien
Boisg√©rault</a>, MINES ParisTech</p>
<p class="date">Vendredi 20 mai 2022</p>

<p>
<span style="display:inline-block;width:1em;position:relative;margin-right:0.25em">
<img height="auto" src="icons/github.svg" style="position:relative;top:0.15em;" width="100%"/>
</span>
<a href="https://github.com/boisgera/python-fr">
          https://github.com/boisgera/python-fr
        </a>
</p>

<p>
<span style="display:inline-block;width:1em;position:relative;margin-right:0.25em">
<img height="auto" src="icons/git.svg" style="position:relative;top:0.15em;" width="100%"/>
</span>
<a href="https://github.com/boisgera/python-fr/commit/b358cff">
          #b358cff
        </a>
</p>

<p>
<span style="display:inline-block;width:1em;position:relative;margin-right:0.25em">
<img height="auto" src="icons/edit.svg" style="position:relative;top:0.15em;" width="100%"/>
</span>
<a href="https://github.com/boisgera/python-fr/edit/master/tps/SIR/index.md">
          Edition
        </a>
</p>
</header>
<details>
<summary>
<h2>Table des mati√®res</h2>
</summary>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a></li>
<li><a href="#d√©pendances" id="toc-d√©pendances">D√©pendances</a></li>
<li><a href="#simulation" id="toc-simulation">Simulation</a></li>
<li><a href="#visualisation" id="toc-visualisation">Visualisation</a></li>
<li><a href="#configuration" id="toc-configuration">Configuration</a></li>
<li><a href="#temps-continu" id="toc-temps-continu">Temps
continu</a></li>
<li><a href="#ev√®nements" id="toc-ev√®nements">Ev√®nements</a></li>
<li><a href="#g√©n√©ralisation" id="toc-g√©n√©ralisation">G√©n√©ralisation</a></li>
<li><a href="#tableaux" id="toc-tableaux">Tableaux</a></li>
</ul>
</nav></details>


<h2 id="introduction">Introduction</h2>
<p>Le mod√®le √©pid√©miologique √† compartiments SIR d√©termine l‚Äô√©volution
dans le temps, parmi une population suppos√©e constante de <span class="math inline">\(N\)</span> individus, du nombre d‚Äôindividus
susceptibles d'√™tre infect√©s <span class="math inline">\(S\)</span>, du
nombre d‚Äôindividus infect√©s <span class="math inline">\(I\)</span> et du
nombre d‚Äôindividus en r√©mission (n‚Äôayant plus de sympt√¥mes cliniques)
<span class="math inline">\(R\)</span> (cf.¬†<a href="https://www.nature.com/articles/s41592-020-0856-2">‚ÄúThe SEIRS
model for infectious disease dynamics‚Äù</a> pour la pr√©sentation d‚Äôun
mod√®le plus complet).</p>
<p>Le param√®tre <span class="math inline">\(\beta&gt;0\)</span>
repr√©sente le taux de contagion, <span class="math inline">\(\gamma&gt;0\)</span> le taux de gu√©rison et <span class="math inline">\(\omega&gt;0\)</span> le taux de perte d‚Äôimmunit√©
(ces grandeurs sont homog√®nes √† l‚Äôinverse d'un temps). On d√©finit le
nombre de reproduction de base <span class="math inline">\(R_0\)</span>
par</p>
<p><span class="math display">\[
R_0 := \frac{\beta}{\gamma}
\]</span></p>
<p>En l'absence de naissances et de morts, ces grandeurs √©voluent selon
les √©quations :</p>
<p><span class="math display">\[
\dot{S}(t) = \omega R(t) - \beta \frac{I(t)S(t)}{N}
\]</span></p>
<p><span class="math display">\[
\dot{I}(t) = \beta \frac{I(t)S(t)}{N} - \gamma  I(t)
\]</span></p>
<p><span class="math display">\[
\dot{R}(t) = \gamma I(t) - \omega R(t)
\]</span></p>
<h2 id="d√©pendances">D√©pendances</h2>
<p>Python 3, NumPy, SciPy, Matplotlib.</p>
<pre class="python"><code>from numpy import *
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt</code></pre>
<h2 id="simulation">Simulation</h2>
<p>On d√©finit les constantes</p>
<pre class="python"><code>WEEK = 7
YEAR = 365</code></pre>
<p>et</p>
<pre class="python"><code>N = 100
beta = 1 / (WEEK)
gamma = 1 / (2 * WEEK)
omega = 1 / YEAR</code></pre>
<h4 id="simulation-avec-solve_ivp">üöÄ Simulation avec
<code>solve_ivp</code></h4>
<p>D√©velopper une fonction <code>dSIR</code> telle que le code</p>
<pre class="python"><code>S0, I0 = 99.0, 1.0
R0 = N - S0 - I0
t_span = [0.0, 5*YEAR]
results = solve_ivp(dSIR, t_span=t_span, y0=(S0, I0, R0))</code></pre>
<p>fournisse les r√©sultats d‚Äôune simulation du mod√®le SIR sur 5 ans avec
une population initiale de 1 % de personnes infect√©es.</p>
<p>(R√©f√©rence : üìñ <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html"><code>solve_ivp</code></a>)</p>
<details>
<summary>
<h4 id="solution">‚ú® Solution</h4>
</summary>
<pre class="python"><code>def dSIR(t, SIR):
    S, I, R = SIR
    dS = omega * R - beta * I * S / N
    dI = beta * I * S / N - gamma * I
    dR = gamma * I - omega * R  
    return (dS, dI, dR)</code></pre>
<p>Si vous √™tes familier des fermetures, et que la pr√©sence d‚Äôun
argument <code>t</code> ‚Äúqui ne sert √† rien‚Äù vous titille, vous pouvez
√©galement d√©finir la fonction d‚Äôordre sup√©rieur</p>
<pre class="python"><code>def autonomous(fx):
    def f_tx(t, x):
        return fx(x)
    return f_tx</code></pre>
<p>et l‚Äôexploiter comme un d√©corateur pour d√©finir <code>dSIR</code>
sans le param√®tre <code>t</code> :</p>
<pre class="python"><code>@autonomous
def dSIR(SIR):
    S, I, R = SIR
    dS = omega * R - beta * I * S / N
    dI = beta * I * S / N - gamma * I
    dR = gamma * I - omega * R  
    return (dS, dI, dR)</code></pre>
</details>
<h2 id="visualisation">Visualisation</h2>
<h4 id="visualisation-des-r√©sultats">üöÄ Visualisation des r√©sultats</h4>
<p>D√©veloppez une fonction <code>plot</code> √† invoquer par :</p>
<pre class="python"><code>plot(**results)</code></pre>
<p>qui produise le graphique :</p>
<p><img src="images/SIR-discrete.svg"/></p>
<details>
<summary>
<h4 id="solution-1">‚ú® Solution</h4>
</summary>
<p>Les donn√©es dont nous avons besoin dans le dictionnaire
<code>results</code> sont associ√©es aux cl√©s <code>"t"</code> et
<code>"y"</code>. Si elles √©taient les seules donn√©es pr√©sentes dans
<code>results</code>, nous pourrions d√©finir une fonction
<code>plot</code> de signature :</p>
<pre class="python"><code>def plot(t, y):
    pass</code></pre>
<p>et l‚Äôappel <code>plot(**results)</code> assignerait aux param√®tres
<code>t</code> et <code>y</code> les donn√©es correspondantes de
<code>result</code>. Mais en pratique, <code>results</code> contient
d‚Äôautre donn√©es :</p>
<pre class="python"><code>&gt;&gt;&gt; list(results.keys())
['t', 'y', 'sol', 't_events', 'y_events', 'nfev', ...]</code></pre>
<p>Or √† ce stade notre fonction n‚Äôaccepte pas les param√®tres nomm√©s
<code>sol</code>, <code>t_events</code>, etc. L‚Äôappel √†
<code>plot</code> √©choue donc logiquement :</p>
<pre class="python"><code>&gt;&gt;&gt; plot(**result)
Traceback (most recent call last):
...
TypeError: plot() got an unexpected keyword argument 'sol'</code></pre>
<p>Une fa√ßon de changer cette situation est d‚Äôintroduire un
‚Äúramasse-miettes‚Äù, sous la forme d‚Äôun dictionnaire collectant les
donn√©es de<code>result</code> qui ne sont pas associ√©es aux cl√©s
<code>"t"</code> ou <code>"y"</code>. Pour ce faire, la notation
<code>**</code> est utilis√©e ; le dictionnaire associ√© est ici nomm√©
<code>_</code> pour indiquer qu‚Äôon ne fera pas usage de son contenu
(cela n‚Äôest pas obligatoire, juste une convention).</p>
<pre class="python"><code>def plot(t, y, **_):
    print(list(_.keys()))</code></pre>
<pre class="python"><code>&gt;&gt;&gt; plot(**results)
['sol', 't_events', 'y_events', ...]</code></pre>
<p>Avec cette technique, la fonction suivante fait l‚Äôaffaire :</p>
<pre class="python"><code>def plot(t, y, **_):
    plt.plot(t, y.T, "-+", label=["S", "I", "R"])
    plt.xlabel("Temps (ann√©es)")
    xlabels = [str(i) for i in range(5+1)]
    plt.xticks(arange(0, 5*YEAR+1, YEAR), xlabels)
    plt.ylabel("Populations (%)")
    plt.yticks(arange(0, 101, 10))
    plt.axis([0, 5*YEAR, 0, 100])
    plt.legend()
    plt.grid(True)</code></pre>
</details>
<h2 id="configuration">Configuration</h2>
<p>Apr√®s examen de vos r√©sultats pr√©liminaires, les sp√©cialistes de la
dynamique vous font par de r√©glages √† effectuer sur la m√©thode du
simulation. Leurs pr√©conisations prennent la forme d‚Äôun fichier
<code>options.py</code> √† utiliser avec <code>solve_ivp</code> :</p>
<pre class="python"><code>{
    "method": "Radau",
    "rtol": 1e-3,
    "atol": 1e-6
}</code></pre>
<h4 id="r√©glages">üöÄ R√©glages</h4>
<p>Prenez en compte le fichier d‚Äôoptions que l‚Äôon vous a donn√©.</p>
<details>
<summary>
<h4 id="solution-2">‚ú® Solution</h4>
</summary>
<pre class="python"><code>options = eval(open("options.py").read())
results = solve_ivp(
    dSIR, 
    t_span=t_span, 
    y0=(S0, I0, R0), 
    **options
)</code></pre>
<p><img src="images/SIR-options.svg"/></p>
</details>
<h2 id="temps-continu">Temps continu</h2>
<p>Lorsque <code>solve_ivp</code> est invoqu√© avec
<code>dense_output=True</code></p>
<pre class="python"><code>results = solve_ivp(
    dSIR, 
    t_span=t_span, 
    y0=(S0, I0, R0), 
    dense_output=True
)</code></pre>
<p>ses r√©sultats comportent, en plus des donn√©es discr√®tes
<code>t</code> et <code>y</code>, une approximation de la solution comme
une fonction du temps.</p>
<pre class="python"><code>&gt;&gt;&gt; sol = results["sol"]</code></pre>
<p>Cette fonctionalit√© nous permet de r√©aliser une nouvelle version de
la fonction <code>plot</code>, telle que :</p>
<pre class="python"><code>&gt;&gt;&gt; t = arange(0, 5*YEAR) # a value every day for 5 years.
&gt;&gt;&gt; plot(t, **results)</code></pre>
<p>produise le graphique :</p>
<p><img src="images/SIR-dense.svg"/></p>
<h4 id="exploitation-des-dense-outputs">üöÄ Exploitation des ‚Äúdense
outputs‚Äù</h4>
<p>V√©rifier que <code>sol</code> est invocable, puis d√©velopper une
nouvelle version de la fonction <code>plot</code> exploitant les ‚Äúdense
outputs‚Äù de <code>solve_ivp</code> pour r√©aliser le graphe voulu.</p>
<details>
<summary>
<h4 id="solution-3">‚ú® Solution</h4>
</summary>
<pre class="python"><code>&gt;&gt;&gt; sol = results["sol"]
&gt;&gt;&gt; sol
&lt;scipy.integrate._ivp.common.OdeSolution at ...&gt;
&gt;&gt;&gt; callable(sol)
True</code></pre>
<pre class="python"><code>def plot(t_, sol, **_):
    plt.plot(t_, sol(t_).T, "-", label=["S", "I", "R"])
    plt.xlabel("Temps (ann√©es)")
    xlabels = [str(i) for i in range(5+1)]
    plt.xticks(arange(0, 5*YEAR+1, YEAR), xlabels)
    plt.ylabel("Populations (%)")
    plt.yticks(arange(0, 101, 10))
    plt.axis([0, 5*YEAR, 0, 100])
    plt.legend()
    plt.grid(True)</code></pre>
</details>
<h2 id="ev√®nements">Ev√®nements</h2>
<h4 id="seuils-dinfection">üöÄ Seuils d‚Äôinfection</h4>
<p>Utiliser le param√®tre <code>events</code> de <code>solve_ivp</code>
pour d√©tecter les instants o√π le nombre d‚Äôinfect√©s passe en-dessous ou
au-dessus de 10 %. Adapter une nouvelle fois la fonction
<code>plot</code> pour repr√©senter ces √©v√®nements comme des points noirs
sur la courbe associ√©e √† la variable <span class="math inline">\(I\)</span>.</p>
<p><img src="images/SIR-events.svg"/></p>
<p>Comment r√©organiser votre programme pour prendre en charge facilement
un seuil d‚Äôinfection arbitraire et non pas fixe √† 10 % ?</p>
<details>
<summary>
<h4 id="solution-4">‚ú® Solution</h4>
</summary>
<pre class="python"><code>def event(t, SIR):
    S, I, R = SIR
    return I - 10.0</code></pre>
<pre class="python"><code>results = solve_ivp(
    dSIR, 
    y0=(S0, I0, R0), 
    t_span=t_span, 
    dense_output=True, 
    events=[event]
)</code></pre>
<pre class="python"><code>def plot(t_, sol, t_events, **_):
    plt.plot(t_, sol(t_).T, "-", label=["S", "I", "R"])
    t_event = t_events[0]
    plt.plot(t_event, sol(t_event)[1], "k.")
    plt.xlabel("Temps (ann√©es)")
    xlabels = [str(i) for i in range(5+1)]
    plt.xticks(arange(0, 5*YEAR+1, YEAR), xlabels)
    plt.ylabel("Populations (%)")
    plt.yticks(arange(0, 101, 10))
    plt.axis([0, 5*YEAR, 0, 100])
    plt.legend()
    plt.grid(True)</code></pre>
<p>La solution ‚Äú√©vidente‚Äù pour prendre en charge une seuil limite qui
peut varier est d‚Äôutiliser une variable globale :</p>
<pre class="python"><code>I_max = 2.0

def event(t, SIR):
    S, I, R = SIR
    return I - I_max</code></pre>
<p>L‚Äôavantage est que le code appelant la simulation est inchang√© :</p>
<pre class="python"><code>results = solve_ivp(
    dSIR, 
    y0=(S0, I0, R0), 
    t_span=t_span, 
    dense_output=True, 
    events=[event]
)</code></pre>
<pre class="python"><code>&gt;&gt;&gt; plot(t, **results)</code></pre>
<p><img src="images/SIR-events-2.svg"/></p>
<p>Si vous n‚Äôaimez pas beaucoup les variables globales, vous pouvez les
√©viter en utilisant une fonction d‚Äôordre sup√©rieur qui renvoie une
fonction <code>event</code> :</p>
<pre class="python"><code>def I_crosses(I_threshold):
    def event(t, SIR):
        S, I, R = SIR
        return I - I_threshold
    return event</code></pre>
<p>Vous l‚Äôexploitez alors de la fa√ßon suivante :</p>
<pre class="python"><code>results = solve_ivp(
    dSIR, 
    y0=(S0, I0, R0), 
    t_span=t_span, 
    dense_output=True, 
    events=[I_crosses(2.0)]
)</code></pre>
<p>avec les m√™me r√©sultats que pr√©c√©demment</p>
</details>
<h2 id="g√©n√©ralisation">G√©n√©ralisation</h2>
<p>Vous avez sans doute remarqu√© que la dynamique du mod√®le SIR est
enti√®rement d√©termin√©e par les flux existant entre les ‚Äúcompartiments‚Äù
de population <span class="math inline">\(S\)</span>, <span class="math inline">\(I\)</span> et <span class="math inline">\(R\)</span>, qui peuvent √™tre d√©crits par la
structure :</p>
<pre class="python"><code>SIR_dynamics = {
 ("S", "I"): "beta * I * S / N",
 ("I", "R"): "gamma * I",
 ("R", "S"): "omega * R"
}</code></pre>
<p>Au lieu d‚Äô√©crire ‚Äú√† la main‚Äù la fonction <code>dSIR</code> comme
pr√©c√©demment, on peut d√©finir une fonction <code>make_d_state</code> qui
prend comme argument le type de dictionnaire ci-dessus et produit
automatiquement la fonction <code>dSIR_auto</code><a class="footnote-ref" href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>
:</p>
<pre class="python"><code>dSIR_manu = dSIR
dSIR_auto = make_dstate(SIR_dynamics)</code></pre>
<h4 id="cr√©ation-du-champ-de-vecteurs-de-la-dynamique">üöÄ Cr√©ation du
champ de vecteurs de la dynamique</h4>
<p>Impl√©menter la fonction <code>make_dstate</code>. On v√©rifiera que
les comportements de la version manuelle et automatique sont identiques.
Par exemple :</p>
<pre class="python"><code>&gt;&gt;&gt; dSIR_manu(0.0, (1/3, 1/3, 1/3))
(0.0007545118504022613, -0.023650793650793648, 0.02289628180039139)
&gt;&gt;&gt; dSIR_auto(0.0, (1/3, 1/3, 1/3))
(0.0007545118504022613, -0.023650793650793648, 0.02289628180039139)</code></pre>
<details>
<summary>
<h4 id="solution-5">‚ú® Solution</h4>
</summary>
<pre class="python"><code>def get_vars(dynamics):
    vars = []
    for pair in dynamics.keys():
        vars.extend(pair)
    # remove duplicated vars
    return list(set(vars))</code></pre>
<pre class="python"><code>&gt;&gt;&gt; get_vars(SIR_dynamics)
['S', 'I', 'R']</code></pre>
<pre class="python"><code>def make_dstate(dynamics):
    vars = get_vars(dynamics)
    
    def fun(t, state):
        ns = globals().copy()
        for var, value in zip(vars, state):
            ns[var] = value
        dstate = []
        for var in vars:
            d = 0
            for (edge, expr) in dynamics.items():
                source, target = edge
                if source == var:
                    d -= eval(expr, ns)
                if target == var:
                    d += eval(expr, ns)
            dstate.append(d)
        return dstate
        
    return fun </code></pre>
</details>
<h1 id="tableaux">Tableaux</h1>
<p>On reproduit ici l‚Äôint√©gralit√© du code qui permet de g√©n√©rer la
s√©quence des valeurs journali√®res de <span class="math inline">\(S\)</span>, <span class="math inline">\(I\)</span>
et <span class="math inline">\(R\)</span> pendant les 5 premi√®res ann√©es
de l‚Äô√©pid√©mie :</p>
<pre class="python"><code>from numpy import *
from scipy.integrate import solve_ivp

WEEK = 7
YEAR = 365
beta = 1 / (WEEK)
gamma = 1 / (2 * WEEK)
omega = 1 / YEAR

N = 100
S0, I0 = 99.0, 1.0
R0 = N - S0 - I0

def dSIR(t, SIR):
    S, I, R = SIR
    dS = omega * R - beta * I * S / N
    dI = beta * I * S / N - gamma * I
    dR = gamma * I - omega * R  
    return (dS, dI, dR)

t_span = [0.0, 5*YEAR]

results = solve_ivp(
    dSIR, 
    y0=(S0, I0, R0), 
    t_span=t_span, 
    dense_output=True, 
)

t = arange(0, 5*YEAR)
S, I, R = results["sol"](t)</code></pre>
<h4 id="cr√©ation">üöÄ Cr√©ation</h4>
<p>Cr√©er un <strong>tableau de donn√©es</strong> (üá∫üá∏
<strong>dataframe</strong>) <a href="https://pandas.pydata.org/">pandas</a> stockant les valeurs
journali√®res de <span class="math inline">\(S\)</span>, <span class="math inline">\(I\)</span> et <span class="math inline">\(R\)</span> dans des colonnes de m√™me nom. Ajouter
ensuite les colonnes des valeurs (constantes dans notre mod√®le) <span class="math inline">\(\beta\)</span>, <span class="math inline">\(\gamma\)</span> et <span class="math inline">\(\omega\)</span> (on nommera les colonnes
correspondantes <code>beta</code>, <code>gamma</code> et
<code>omega</code>). Afficher un r√©sum√© du tableau avant et apr√®s cet
ajout.</p>
<details>
<summary>
<h4 id="solution-6">‚ú® Solution</h4>
</summary>
<pre class="python"><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; df = pd.DataFrame({"S":S, "I": I, "R": R})
&gt;&gt;&gt; df # doctest: +ELLIPSIS
              S         I          R
0     99.000000  1.000000   0.000000
1     98.853717  1.072397   0.073885
2     98.697303  1.149788   0.152909
3     98.530103  1.232472   0.237425
4     98.351424  1.320767   0.327809
                      ...
1820  50.279454  1.851949  47.868597
1821  50.277556  1.852686  47.869759
1822  50.275613  1.853418  47.870969
1823  50.273626  1.854145  47.872229
1824  50.271597  1.854867  47.873536

[1825 rows x 3 columns]</code></pre>
<pre class="python"><code>df["beta"] = beta
df["gamma"] = gamma
df["omega"] = omega</code></pre>
<pre class="python"><code>&gt;&gt;&gt; df
              S         I          R      beta     gamma    omega
0     99.000000  1.000000   0.000000  0.142857  0.071429  0.00274
1     98.853717  1.072397   0.073885  0.142857  0.071429  0.00274
2     98.697303  1.149788   0.152909  0.142857  0.071429  0.00274
3     98.530103  1.232472   0.237425  0.142857  0.071429  0.00274
4     98.351424  1.320767   0.327809  0.142857  0.071429  0.00274
                                 ...
1820  50.279454  1.851949  47.868597  0.142857  0.071429  0.00274
1821  50.277556  1.852686  47.869759  0.142857  0.071429  0.00274
1822  50.275613  1.853418  47.870969  0.142857  0.071429  0.00274
1823  50.273626  1.854145  47.872229  0.142857  0.071429  0.00274
1824  50.271597  1.854867  47.873536  0.142857  0.071429  0.00274

[1825 rows x 6 columns]</code></pre>
</details>
<h4 id="calculs">üßÆ Calculs</h4>
<p>L‚Äô√©tape pr√©c√©dente a stock√© dans le tableau toutes les donn√©es dont
on aura besoin par la suite. Les grandeurs qu‚Äôon pourra d√©sormais y
ajouter se d√©duiront des donn√©es qui y sont stock√©.</p>
<ul>
<li><p>Ajoutez une colonne <code>N</code> dont les valeurs sont les
sommes de <code>S</code>, <code>I</code> et <code>R</code>, puis ajoutez
une colonne <code>R0</code> calculant la ratio entre <code>beta</code>
et <code>gamma</code>.</p></li>
<li><p>L‚Äô√©pid√©mie a commenc√© le 1er janvier 2020. Cr√©ez une colonne
<code>date</code> donnant le jour associ√© √† chaque ligne de donn√©e, puis
l‚Äôadopter comme index (plut√¥t que d‚Äôutiliser l‚Äôentier qui nous a servi
jusqu‚Äô√† pr√©sent).</p></li>
<li><p>Calculer le nombre de nouveaux infect√©s <span class="math inline">\(\beta I S/N\)</span> chaque jour et d√©finir une
nouvelle colonne <code>T</code> comptabilisant le nombre total d‚Äôinfect√©
depuis le d√©but de l‚Äô√©pid√©mie.</p></li>
</ul>
<details>
<summary>
<h4 id="solution-7">‚ú® Solution</h4>
</summary>
<pre class="python"><code>df["N"] = df["S"] + df["I"] + df["R"]
df["R0"] = df["beta"] / df["gamma"]</code></pre>
<pre class="python"><code>&gt;&gt;&gt; df # doctest: +ELLIPSIS
              S         I          R  ...    omega      N   R0
0     99.000000  1.000000   0.000000  ...  0.00274  100.0  2.0
1     98.853717  1.072397   0.073885  ...  0.00274  100.0  2.0
2     98.697303  1.149788   0.152909  ...  0.00274  100.0  2.0
3     98.530103  1.232472   0.237425  ...  0.00274  100.0  2.0
4     98.351424  1.320767   0.327809  ...  0.00274  100.0  2.0
      ...
1820  50.279454  1.851949  47.868597  ...  0.00274  100.0  2.0
1821  50.277556  1.852686  47.869759  ...  0.00274  100.0  2.0
1822  50.275613  1.853418  47.870969  ...  0.00274  100.0  2.0
1823  50.273626  1.854145  47.872229  ...  0.00274  100.0  2.0
1824  50.271597  1.854867  47.873536  ...  0.00274  100.0  2.0

[1825 rows x 8 columns]</code></pre>
<pre class="python"><code>&gt;&gt;&gt; datetime64("2020-01-01")
numpy.datetime64('2020-01-01')
&gt;&gt;&gt; start = datetime64("2020-01-01")
&gt;&gt;&gt; end = start + len(df["S"]) - 1
&gt;&gt;&gt; start
numpy.datetime64('2020-01-01')
&gt;&gt;&gt; end
numpy.datetime64('2024-12-29')
&gt;&gt;&gt; dates = pd.date_range(start, end)
&gt;&gt;&gt; dates # doctest: +ELLIPSIS
DatetimeIndex(['2020-01-01', '2020-01-02', '2020-01-03', '2020-01-04',
               '2020-01-05', '2020-01-06', '2020-01-07', '2020-01-08',
               '2020-01-09', '2020-01-10',
               ...
               '2024-12-20', '2024-12-21', '2024-12-22', '2024-12-23',
               '2024-12-24', '2024-12-25', '2024-12-26', '2024-12-27',
               '2024-12-28', '2024-12-29'],
              dtype='datetime64[ns]', length=1825, freq='D')
&gt;&gt;&gt; df["date"] = dates
&gt;&gt;&gt; df # doctest: +ELLIPSIS
              S         I          R  ...      N   R0       date
0     99.000000  1.000000   0.000000  ...  100.0  2.0 2020-01-01
1     98.853717  1.072397   0.073885  ...  100.0  2.0 2020-01-02
2     98.697303  1.149788   0.152909  ...  100.0  2.0 2020-01-03
3     98.530103  1.232472   0.237425  ...  100.0  2.0 2020-01-04
4     98.351424  1.320767   0.327809  ...  100.0  2.0 2020-01-05
      ...
1820  50.279454  1.851949  47.868597  ...  100.0  2.0 2024-12-25
1821  50.277556  1.852686  47.869759  ...  100.0  2.0 2024-12-26
1822  50.275613  1.853418  47.870969  ...  100.0  2.0 2024-12-27
1823  50.273626  1.854145  47.872229  ...  100.0  2.0 2024-12-28
1824  50.271597  1.854867  47.873536  ...  100.0  2.0 2024-12-29

[1825 rows x 9 columns]
&gt;&gt;&gt; df = df.set_index("date")
&gt;&gt;&gt; df
                    S         I          R  ...    omega      N   R0
date                                        ...                     
2020-01-01  99.000000  1.000000   0.000000  ...  0.00274  100.0  2.0
2020-01-02  98.853717  1.072397   0.073885  ...  0.00274  100.0  2.0
2020-01-03  98.697303  1.149788   0.152909  ...  0.00274  100.0  2.0
2020-01-04  98.530103  1.232472   0.237425  ...  0.00274  100.0  2.0
2020-01-05  98.351424  1.320767   0.327809  ...  0.00274  100.0  2.0
                                            ...
2024-12-25  50.279454  1.851949  47.868597  ...  0.00274  100.0  2.0
2024-12-26  50.277556  1.852686  47.869759  ...  0.00274  100.0  2.0
2024-12-27  50.275613  1.853418  47.870969  ...  0.00274  100.0  2.0
2024-12-28  50.273626  1.854145  47.872229  ...  0.00274  100.0  2.0
2024-12-29  50.271597  1.854867  47.873536  ...  0.00274  100.0  2.0

[1825 rows x 8 columns]</code></pre>
<pre class="python"><code>&gt;&gt;&gt; df = df.eval("new_I = beta * I * S / N")
&gt;&gt;&gt; df # doctest: +ELLIPSIS
                    S         I          R  ...      N   R0     new_I
date                                        ...                      
2020-01-01  99.000000  1.000000   0.000000  ...  100.0  2.0  0.141429
2020-01-02  98.853717  1.072397   0.073885  ...  100.0  2.0  0.151444
2020-01-03  98.697303  1.149788   0.152909  ...  100.0  2.0  0.162116
2020-01-04  98.530103  1.232472   0.237425  ...  100.0  2.0  0.173479
2020-01-05  98.351424  1.320767   0.327809  ...  100.0  2.0  0.185570
                                            ...
2024-12-25  50.279454  1.851949  47.868597  ...  100.0  2.0  0.133021
2024-12-26  50.277556  1.852686  47.869759  ...  100.0  2.0  0.133069
2024-12-27  50.275613  1.853418  47.870969  ...  100.0  2.0  0.133117
2024-12-28  50.273626  1.854145  47.872229  ...  100.0  2.0  0.133164
2024-12-29  50.271597  1.854867  47.873536  ...  100.0  2.0  0.133210

[1825 rows x 9 columns]</code></pre>
<pre class="python"><code>&gt;&gt;&gt; df["T"] = df["new_I"].cumsum()
&gt;&gt;&gt; df # doctest: + ELLIPSIS
                    S         I          R  ...   R0     new_I     T
date                                        ...                           
2020-01-01  99.000000  1.000000   0.000000  ...  2.0  0.141429    0.141429
2020-01-02  98.853717  1.072397   0.073885  ...  2.0  0.151444    0.292872
2020-01-03  98.697303  1.149788   0.152909  ...  2.0  0.162116    0.454988
2020-01-04  98.530103  1.232472   0.237425  ...  2.0  0.173479    0.628467
2020-01-05  98.351424  1.320767   0.327809  ...  2.0  0.185570    0.814038
                                            ...
2024-12-25  50.279454  1.851949  47.868597  ...  2.0  0.133021  286.095531
2024-12-26  50.277556  1.852686  47.869759  ...  2.0  0.133069  286.228601
2024-12-27  50.275613  1.853418  47.870969  ...  2.0  0.133117  286.361717
2024-12-28  50.273626  1.854145  47.872229  ...  2.0  0.133164  286.494881
2024-12-29  50.271597  1.854867  47.873536  ...  2.0  0.133210  286.628091

[1825 rows x 10 columns]</code></pre>
</details>
<h4 id="graphiques">Graphiques</h4>
<ol type="1">
<li><p>Repr√©sentez graphiquement avec la m√©thode <code>plot</code> des
tableaux pandas le contenu du tableau de donn√©es.</p></li>
<li><p>Renouvellez l‚Äôop√©ration en ne repr√©sentant que les valeurs de
<code>S</code>, <code>I</code> et <code>R</code>.</p></li>
<li><p>Renouvellez l‚Äôop√©ration en ne repr√©sentant que les valeurs de
<code>S</code>, <code>I</code> et <code>R</code> et en utilisant la
m√©thode <code>plot.area</code> avec l‚Äôoption
<code>stacked=True</code>.</p></li>
<li><p>Revenir √† l‚Äô√©tape 2 en ajoutant <code>T</code> au jeu de
variables repr√©sent√©es.</p></li>
<li><p>Repr√©senter les m√™me variables avec la m√™me m√©thode, mais
uniquement sur la premi√®re ann√©e de l‚Äô√©pid√©mie.</p></li>
</ol>
<p><img src="images/SIR-pandas-5.svg"/></p>
<details>
<summary>
<h4 id="solution-8">‚ú® Solution</h4>
</summary>
<pre class="python"><code>&gt;&gt;&gt; import matplotlib.pyplot as plt</code></pre>
<pre class="python"><code>&gt;&gt;&gt; df.plot()
&gt;&gt;&gt; plt.show()</code></pre>
<p><img src="images/SIR-pandas-1.svg"/></p>
<pre class="python"><code>&gt;&gt;&gt; df_SIR = df[["S", "I", "R"]]
&gt;&gt;&gt; df_SIR.plot()
&gt;&gt;&gt; plt.show()</code></pre>
<p><img src="images/SIR-pandas-2.svg"/></p>
<pre class="python"><code>&gt;&gt;&gt; df_SIR.plot.area(stacked=True)
&lt;AxesSubplot:xlabel='date'&gt;
&gt;&gt;&gt; plt.ylim((0.0, 100.0))
(0.0, 100.0)
&gt;&gt;&gt; plt.show()</code></pre>
<p><img src="images/SIR-pandas-3.svg"/></p>
<pre class="python"><code>&gt;&gt;&gt; df_SIRT = df[["S", "I", "R", "T"]]
&gt;&gt;&gt; df_SIRT.plot()
&gt;&gt;&gt; plt.show()</code></pre>
<p><img src="images/SIR-pandas-4.svg"/></p>
<pre class="python"><code>&gt;&gt;&gt; df_SIRT_1st_year = df_SIRT["2020-01-01":"2021-01-01"] 
&gt;&gt;&gt; df_SIRT_1st_year.plot()
&lt;AxesSubplot:xlabel='date'&gt;
&gt;&gt;&gt; plt.show()</code></pre>
<p><img src="images/SIR-pandas-5.svg"/></p>
</details>
<h4 id="export">Export</h4>
<p>Exporter votre tableau pandas au formats CSV, puis ouvrez une des
deux versions avec LibreOffice, Google Sheets ou Excel (ou application
√©quivalente de votre choix.</p>
<p><img src="images/SIR-CSV.png"/></p>
<details>
<summary>
<h4 id="solution-9">‚ú® Solution</h4>
</summary>
<pre class="python"><code>&gt;&gt;&gt; df.to_csv("SIR.csv")</code></pre>
</details>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr/>
<ol>
<li id="fn1" role="doc-endnote"><p>On peut ainsi √©viter les erreurs dans
la traduction du mod√®le de flux en √©quations diff√©rentielles, d√©finir
plus rapidement de nouveaux mod√®les compartimentaux, etc.<a class="footnote-back" href="#fnref1" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
</ol>
</section>
</body>
</html>
