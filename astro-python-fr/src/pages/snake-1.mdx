---
title: Le serpent
author: "[S√©bastien Boisg√©rault](mailto:Sebastien.Boisgerault@minesparis.psl.eu), 
Mines Paris -- PSL"
license: "[CC BY 4.0](https://creativecommons.org/licenses/by/4.0/)"
layout: ../layouts/MDXLayout.astro
---

import Admonition from '/src/components/Admonition.astro';
import { Image } from 'astro:assets';


import snake from "/src/assets/snake.jpg";

<Image src={snake} alt="Boa constrictor by Jan Kop≈ôiva"/>

Projet original par Aur√©lien Noce (aka [@ushu](https://github.com/ushu)).

{/* ## Table des mati√®res */}

## Introduction

Ce TP vous propose de d√©velopper un petit jeu en Python.
Il constitue une introduction √† la conception et √† la r√©alisation
d'un programme complet.

Son sujet est un standard du jeu vid√©o, le üêç [snake].

[[üéÆ Snake!](https://kitao.github.io/pyxel/wasm/examples/07_snake.html) ;
une version classique du snake, r√©alis√©e avec la plate-forme de retro-gaming
Python [Pyxel](https://github.com/kitao/pyxel).](images/snake-pyxel.jpg)

De nombreuses variantes de ce jeu existent ; [slither.io](https://slither.io)
est un bon exemple de snake modernis√© (et notamment, massivement multijoueur !).

[snake]: https://fr.wikipedia.org/wiki/Snake_(genre_de_jeu_vid%C3%A9o)

Rassurez-vous, notre objectif sera modeste et donc proche de la version
classique du jeu : nous r√©aliserons plusieurs versions d'un **programme qui marche**
(et pas un programme parfait) dont les fonctionnalit√©s s'enrichiront √†
chaque nouvelle √©tape.

## C'est parti !

Notre point de d√©part : un message dont la couleur varie avec le temps.

<video controls width="768">
  <source src="/videos/hello-snake.webm" type="video/webm" />
</video>

```python
import pyxel

def update():
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()

def draw():
    pyxel.cls(0)
    pyxel.text(56, 54, "Hello, Snake!", pyxel.frame_count % 16)

pyxel.init(160, 120, title="Hello Pyxel")
pyxel.run(update, draw)
```

## Comment √ßa marche ?

**TODO:**

  - couleurs: faire le tour des possibles, renvoyer sur la "doc"?

  - Text: comprendre la taille (fixe) de chaque caract√®re,
    display d'une "grille" de caract√®res., comprendre comment est
    plac√© le "Hello world!", ajuster le programme pour que le texte
    soit toujours centr√© (m√™me si plusieurs lignes ?).

## Nombre d'images par seconde

La fonction `time.time` de la biblioth√®que standard Python renvoie le temps 
√©coul√© en secondes depuis le 1er janvier 1970 √† midi.

```
>>> import time
>>> time.time()
1692980870.0990813
>>> time.time()
1692980871.2445116
>>> time.time()
1692980872.3245282
```
Utilisez-l√† pour mesurer le temps qui s'√©coule entre deux appels √† la fonction
`draw` de Pyxel. Puis, affichez le nombre d'images par seconde 
(ou FPS pour *frames per second*) dans le coin en haut √† gauche de la fen√™tre.

<video controls width="768">
  <source src="/videos/fps.webm" type="video/webm" />
</video>


<Admonition type="solution" open={false} >
```python
import math
import time
import pyxel

def update():
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()

def draw():
    global t
    t_new = time.time()
    dt = t_new - t
    t = t_new
    fps = 1.0 / dt
    pyxel.cls(0)
    pyxel.text(0, 0, f"fps: {int(round(fps))}", 7)

pyxel.init(160, 120, title="üêç Snake")
t = time.time()
pyxel.run(update, draw)
```
</Admonition>

## Ev√®nements

  - √©v√®nement claviers: d√©tecter les fl√®ches, afficher les symboles,
    avec ceux qui sont press√©s d'une couleur diff√©rente (plus vive).

  - √©ventuellement: "P" pour pause ? Plus rien n'est mis √† jour ?
   (sauf la d√©tection de la touche "P")

## √âv√©nements

Pygame permet de sp√©cifier comment r√©agir aux actions de l'utilisateur,
par exemple son utilisation du clavier ou de la souris.

Nous pouvons ainsi faire en sorte de forcer l'arr√™t du programme lorsque
l'utilisateur clique sur le bouton de fermeture de la fen√™tre ou appuie sur
la touche Q :

```python
import random
import sys
import pygame

pygame.init()
screen = pygame.display.set_mode([300, 300])
clock = pygame.time.Clock()

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_q:
                pygame.quit()
                sys.exit()
    red = random.randint(0, 255)
    green = random.randint(0, 255)
    blue = random.randint(0, 255)
    color = [red, green, blue]
    screen.fill(color)
    pygame.display.update()
    clock.tick(1)
```

Modifier ce programme pour que lorsque l'utilisateur presse
les fl√™ches de son clavier, le programme affiche (avec la fonction `print`)
les caract√®res `‚Üê`, `‚Üë`, `‚Üí` ou `‚Üì` dans le terminal.

üóùÔ∏è Le code renvoy√© par la fl√™che vers le haut est `pygame.K_UP` par exemple.

## Le damier

Nous allons commencer par construire notre plateau de jeu ainsi :

- le plateau de jeu est d√©coup√© en 30x30 cases,

- chaque case fait 20 pixels de c√¥t√©.

Pour v√©rifier la validit√© de ce plateau de jeu,
√©crivez un programme qui dessine un damier :

{/* ![](images/damier.png) */}

üóùÔ∏è Vous pouvez utiliser la m√©thode [`pygame.draw.rect`](https://www.pygame.org/docs/ref/draw.html#pygame.draw.rect) :

```python
x = 100
y = 100
width = 30
height = 30
rect = [x, y, width, height]
red = 255
green = 0
blue = 0
color = [red, green, blue]
pygame.draw.rect(screen, color, rect)
```

## Un serpent fixe

> No no he's not dead, he's, he's restin'!

L'√©tape suivante est de dessiner le serpent, comme une suite de segments
repr√©sent√©s par des rectangles color√©s.
On veut dessiner le serpent aux coordonn√©es suivantes :

```python
snake = [
    [10, 15],
    [11, 15],
    [12, 15],
]
```

pour obtenir un sch√©ma comme suit ;
disons pour fixer les id√©es que dans ce cas de figure `[10, 15]` est la queue
et `[12, 15]` est la t√™te :

{/* ![](images/serpent.png) */}

<details>
<summary>
**Solution**
</summary>
```python
import sys
import pygame

white = [255, 255, 255]
black = [0, 0, 0]
snake = [
[10, 15],
[11, 15],
[12, 15],
]

pygame.init()
screen = pygame.display.set_mode([20*30, 20*30])
clock = pygame.time.Clock()
while True:
    for event in pygame.event.get():
    if event.type == pygame.QUIT:
        pygame.quit()
        sys.exit()
    elif event.type == pygame.KEYDOWN:
        if event.key == pygame.K_q:
            pygame.quit()
            sys.exit()
    screen.fill(white)
    for x, y in snake:
        rect = [x*20, y*20, 20, 20]
        pygame.draw.rect(screen, black, rect)  
    pygame.display.update()
    clock.tick(1)
```
</details>


Un serpent qui bouge
--------------------------------------------------------------------------------

Ensuite, nous allons faire bouger le serpent :

- nous cr√©ons un vecteur de "direction", par exemple

  ```python
  direction = [1, 0]
  ```

- √† chaque it√©ration de la boucle, nous pouvons d√©placer le serpent dans
  cette direction en "ajoutant" ce vecteur √† la position de la t√™te du serpent

{/* ![](images/serpent-bouge.gif) */}

Une fois que le serpent bouge, ajouter les commandes pour se d√©placer dans
les 4 directions, en appuyant sur les touches de direction du clavier.

Aussi on peut commencer √† envisager d'acc√©l√©rer un peu le jeu √† ce stade ...

**Bonus.** Faites en sorte que le serpent ne puisse pas faire demi-tour.

<details>
<summary>
**Solution**
</summary>

```python
import sys
import pygame

white = [255, 255, 255]
black = [0, 0, 0]
snake = [
    [10, 15],
    [11, 15],
    [12, 15],
]
direction = [1, 0]

pygame.init()
screen = pygame.display.set_mode([20*30, 20*30])
clock = pygame.time.Clock()
while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_q:
                pygame.quit()
                sys.exit()
            if event.key == pygame.K_UP:
                direction = [0.0, -1.0]
            elif event.key == pygame.K_LEFT:
                direction = [-1.0, 0.0]
            elif event.key == pygame.K_DOWN:
                direction = [0.0, 1.0]
            elif event.key == pygame.K_RIGHT:
                direction = [1.0, 0.0]
    head = snake[-1]
    new_head = [
      head[0] + direction[0],
      head[1] + direction[1]
    ]
    snake = snake[1:] + [new_head]
    screen.fill(white)
    for x, y in snake:
        rect = [x*20, y*20, 20, 20]
        pygame.draw.rect(screen, black, rect)
    pygame.display.update()
    clock.tick(1)
```

</details>

## Le fruit

Il faut maintenant faire manger notre serpent.
On va proc√©der comme suit:

- on a toujours la position du serpent dans une variable `snake` :

- on g√©n√®re un "fruit", dans une position al√©atoire

  ```python
  fruit = [10, 10]
  ```

- quand la t√™te du serpent mange le fruit,
  on place un nouveau fruit √† une position al√©atoire
  et on allonge le serpent d'une case

  {/* ![](images/manger.gif) */}

<details>
<summary>
**Solution**
</summary>

```python
import random
import sys
import pygame

white = [255, 255, 255]
black = [0, 0, 0]
red = [255, 0, 0]
snake = [
    [10, 15],
    [11, 15],
    [12, 15],
]
direction = [1, 0]
fruit = [10, 10]

pygame.init()
screen = pygame.display.set_mode([20*30, 20*30])
clock = pygame.time.Clock()
while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_q:
                pygame.quit()
                sys.exit()
            if event.key == pygame.K_UP:
                direction = [0, -1]
            elif event.key == pygame.K_LEFT:
                direction = [-1, 0]
            elif event.key == pygame.K_DOWN:
                direction = [0, 1]
            elif event.key == pygame.K_RIGHT:
                direction = [1, 0]
    head = snake[-1]
    new_head = [
      head[0] + direction[0],
      head[1] + direction[1]
    ]
    if new_head == fruit:
        snake = snake + [new_head]
        fruit = [
            random.randint(0, 29),
            random.randint(0, 29)
        ]
    else:
        snake = snake[1:] + [new_head]
    screen.fill(white)
    for x, y in snake:
        rect = [x*20, y*20, 20, 20]
        pygame.draw.rect(screen, black, rect)
    rect = [fruit[0]*20, fruit[1]*20, 20, 20]
    pygame.draw.rect(screen, red, rect)
    pygame.display.update()
    clock.tick(1)
```

</details>

## √âpilogue

Il nous reste deux petits changements pour avoir un serpent compl√®tement
fonctionnel :

- Il faut d√©tecter si le serpent se mord la queue, ou touche un
  des murs, ce qui est une condition d'√©chec.

- Enfin on peut afficher le score.
  La fa√ßon la plus simple de proc√©der est de changer le titre de la fen√™tre,
  avec la fonction `set_caption` :

  ```python
  score = 0
  pygame.display.set_caption(f"üêç Score: {score}")
  ```

<details>
<summary>
**Solution**
</summary>

```python
import random
import sys
import pygame

white = [255, 255, 255]
black = [0, 0, 0]
red = [255, 0, 0]
snake = [
    [10, 15],
    [11, 15],
    [12, 15],
]
direction = [1, 0]
fruit = [10, 10]
score = 0

pygame.init()
screen = pygame.display.set_mode([20*30, 20*30])
clock = pygame.time.Clock()
while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_q:
                pygame.quit()
                sys.exit()
            if event.key == pygame.K_UP:
                direction = [0, -1]
            elif event.key == pygame.K_LEFT:
                direction = [-1, 0]
            elif event.key == pygame.K_DOWN:
                direction = [0, 1]
            elif event.key == pygame.K_RIGHT:
                direction = [1, 0]
    head = snake[-1]
    new_head = [
      head[0] + direction[0],
      head[1] + direction[1]
    ]
    if (
        new_head in snake
        or new_head[0] < 0
        or new_head[0] >= 30
        or new_head[1] < 0
        or new_head[1] >= 30
    ):
        pygame.quit()
        sys.exit()
    if new_head == fruit:
        score = score + 1
        snake = snake + [new_head]
        fruit = [
            random.randint(0, 29),
            random.randint(0, 29)
        ]
    else:
        snake = snake[1:] + [new_head]
    screen.fill(white)
    for x, y in snake:
        rect = [x*20, y*20, 20, 20]
        pygame.draw.rect(screen, black, rect)
    rect = [fruit[0]*20, fruit[1]*20, 20, 20]
    pygame.draw.rect(screen, red, rect)
    pygame.display.update()
    pygame.display.set_caption(f"üêç Score: {score}")
    clock.tick(1)
```
</details>

## Annexe -- Codes RGB

La couleur d'un pixel est d√©crite par son [code RGB](https://fr.wikipedia.org/wiki/Rouge_vert_bleu) : un triplet d'entiers compris entre 0 et 255 qui d√©terminent
l'intensit√© de ses composantes rouge, verte et bleue.
On a par exemple :

| R         | G        | B        | Couleur |
|-----------|----------|----------|---------|
|       255 |        0 |        0 |      üü• |
|         0 |      255 |        0 |      üü© |
|         0 |        0 |      255 |      üü¶ |
|       255 |      255 |      255 |      ‚¨ú |
|         0 |        0 |        0 |      ‚¨õ |
|       128 |       64 |        0 |      üü´ |
|       255 |      128 |        0 |      üüß |
|       255 |      255 |        0 |      üü® |
|       106 |       13 |      173 |      üü™ |
