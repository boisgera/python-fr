<!DOCTYPE html>

<html lang="fr" xml:lang="fr" xmlns="http://www.w3.org/1999/xhtml">
<head>
<script>
        window.MathJax = {
          tex: {
            tags: 'ams'
          }
        };
       </script>

<meta charset="utf-8"/>
<meta content="pandoc" name="generator"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport"/>
<meta content="SÃ©bastien BoisgÃ©rault, MINES Paris â€“ PSL" name="author"/>
<title>Collections</title>
<style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
<link href="css/style.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&amp;display=swap" rel="stylesheet"/>
<script>

      function filterConsole(text) {
          let lines = text.split("\n");

          console.log(lines);

          let pythonConsole = lines && lines[0].startsWith(">>>");
          if (!pythonConsole) {
              return text + "\n\n";
          } else {
              let newLines = [];
              for (let line of lines) {
                  if (line.startsWith(">>> ") || line.startsWith("... ")) {
                      newLines.push(line.slice(4));
                  } else if (line.startsWith("...")){
                      newLines.push(line.slice(3));
                  }

              }
              return newLines.join("\n") + "\n";
          }

      }

      document.addEventListener("DOMContentLoaded", (event) => {
          let codeBlocks = document.querySelectorAll("pre.python")
          for (let codeBlock of codeBlocks) {

              let button = document.createElement("button")
              let icon = document.createElement("img");
              button.appendChild(icon)
              codeBlock.insertBefore(button, codeBlock.firstChild);

              icon.setAttribute("src", "icons/copy.svg");
              icon.setAttribute("style", "opacity: 0.5;")
              button.addEventListener('click', (event) => {
                  let text = button.nextElementSibling.textContent;
                  text = filterConsole(text);
                  navigator.clipboard.writeText(text);
              });

              codeBlock.setAttribute("style", "position: relative");
              button.setAttribute("style", 
              "position: absolute; right: 1em; top: 1em; opacity: 0.0;");

              codeBlock.addEventListener("mouseover", (event) => {
                  button.style.setProperty("transition", "opacity 0.1s ease-out");
                  button.style.setProperty("opacity", "1.0");
              });

              codeBlock.addEventListener("mouseout", (event) => {
                  button.style.setProperty("transition", "opacity 0.75s ease-out");
                  button.style.setProperty("opacity", "0.0");
              });

              button.addEventListener("mouseover", (event) => {
                  icon.style.setProperty("transition", "opacity 0.1s ease-out");
                  icon.style.setProperty("opacity", "0.75");
              })

              button.addEventListener("mouseout", (event) => {
                  icon.style.setProperty("transition", "opacity 0.75s ease-out");
                  icon.style.setProperty("opacity", "0.5");
              })


          }
      });    
  </script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
<!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Collections</h1>
<p class="author"><a href="mailto:Sebastien.Boisgerault@minesparis.psl.eu">SÃ©bastien
BoisgÃ©rault</a>, MINES Paris â€“ PSL</p>
<p class="date">Friday 25 august 2023</p>

<p>
<span style="display:inline-block;width:1em;position:relative;margin-right:0.25em">
<img height="auto" src="icons/github.svg" style="position:relative;top:0.15em;" width="100%"/>
</span>
<a href="https://github.com/boisgera/python-fr">
          https://github.com/boisgera/python-fr
        </a>
</p>

<p>
<span style="display:inline-block;width:1em;position:relative;margin-right:0.25em">
<img height="auto" src="icons/git.svg" style="position:relative;top:0.15em;" width="100%"/>
</span>
<a href="https://github.com/boisgera/python-fr/commit/7da617f">
          #7da617f
        </a>
</p>
</header>
<details>
<summary>
<h2>Table des matiÃ¨res</h2>
</summary>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#listes" id="toc-listes">Listes</a></li>
<li><a href="#dictionnaires" id="toc-dictionnaires">Dictionnaires</a></li>
<li><a href="#n-uplets" id="toc-n-uplets">N-uplets</a></li>
<li><a href="#ensembles" id="toc-ensembles">Ensembles</a></li>
</ul>
</nav></details>


<h1 id="listes">Listes</h1>
<p>Les listes Python sont des collections ordonnÃ©es dâ€™objets de type
arbitraire. Elles sont (potentiellement) hÃ©tÃ©rogÃ¨nes : il nâ€™est pas
nÃ©cessaire que le type de tous les Ã©lÃ©ments dâ€™une liste soit le mÃªme</p>
<pre class="python"><code>&gt;&gt;&gt; l = [1.0, True, 2, 3]</code></pre>
<p>Les listes sont modifiables ; leurs Ã©lÃ©ments peuvent Ãªtre lus et
Ã©crits avec lâ€™opÃ©ration <code>l[index]</code> ; lâ€™indice du premier
Ã©lÃ©ment est <code>0</code>.</p>
<pre class="python"><code>&gt;&gt;&gt; l[1]
True
&gt;&gt;&gt; l
[1.0, True, 2, 3]
&gt;&gt;&gt; l[1] = 42
[1.0, 42, 2, 3]</code></pre>
<p>La longueur dâ€™une liste est variable ; on peut en retirer des
Ã©lÃ©ments et en ajouter, Ã  une position arbitraire dans la liste.</p>
<pre class="python"><code>&gt;&gt;&gt; len(l)
3
&gt;&gt;&gt; del l[1]
&gt;&gt;&gt; len(l)
2
&gt;&gt;&gt; l
[1.0, 2, 3]
&gt;&gt;&gt; l.append(12)
&gt;&gt;&gt; l
[1.0, 2, 3, 12]
&gt;&gt;&gt;
&gt;&gt;&gt; l.extend([9, 10, 11, 12])
&gt;&gt;&gt; l
[1.0, 2, 3, 12, 9, 10, 11, 12]
&gt;&gt;&gt; l.insert(True, 0)
&gt;&gt;&gt; l
[True, 1.0, 2, 3, 12, 9, 10, 11, 12]</code></pre>
<p>Un indice nÃ©gatif <code>i</code> sera interpÃ©tÃ© comme lâ€™indice
<code>len(l) + i</code>. En particulier, le dernier Ã©lement dâ€™une liste
peut Ãªtre dÃ©signÃ© par lâ€™indice <code>-1</code>.</p>
<pre class="python"><code>&gt;&gt;&gt; l[-1]
12</code></pre>
<p>Il est possible de <strong>dÃ©piler</strong> (ğŸ‡ºğŸ‡¸ <strong>pop</strong>)
un Ã©lÃ©ment dâ€™une liste, câ€™est-Ã -dire de lâ€™enlever de la liste et de
rÃ©cupÃ©rer sa valeur. Par dÃ©faut, câ€™est le dernier Ã©lÃ©ment de la liste
qui est dÃ©pilÃ©, mais cela est configurable.</p>
<pre class="python"><code>&gt;&gt;&gt; l.pop()
12
&gt;&gt;&gt; l
[1.0, 2, 3, 12, 9, 10, 11]
&gt;&gt;&gt; l.pop(0)
1.0
&gt;&gt;&gt; l
[2, 3, 12, 9, 10, 11]</code></pre>
<p>Il est possible de localiser, compter et enlever les Ã©lÃ©ments dâ€™une
liste possÃ©dant une valeur donnÃ©e.</p>
<pre class="python"><code>&gt;&gt;&gt; l
[2, 3, 12, 9, 10, 11]
&gt;&gt;&gt; l.remove(9)
&gt;&gt;&gt; l
[2, 3, 12, 10, 11]
&gt;&gt;&gt; l.index(10)
3
&gt;&gt;&gt; l.count(63)
0</code></pre>
<p>On peut crÃ©er une liste rÃ©sulant de la concatÃ©nation de deux
listes.</p>
<pre class="python"><code>&gt;&gt;&gt; l
[1, 2, 3, 4]
&gt;&gt;&gt; l1 = [1, 2]
&gt;&gt;&gt; l2 = [3, 4]
&gt;&gt;&gt; l3 = l1 + l2
&gt;&gt;&gt; l1
[1, 2]
&gt;&gt;&gt; l2
[3, 4]
&gt;&gt;&gt; l3
[1, 2, 3, 4]</code></pre>
<p>Lâ€™opÃ©ration <code>extend</code> rÃ©alise la mÃªme opÃ©ration, Ã  ceci
prÃ¨s quâ€™elle modifie la liste Ã  Ã©tendre plutÃ´t que de crÃ©er une nouvelle
liste.</p>
<pre class="python"><code>&gt;&gt;&gt; l3 = l1.extend(l2)
&gt;&gt;&gt; l1
[1, 2, 3, 4]
&gt;&gt;&gt; l2
[3, 4]
&gt;&gt;&gt; l3 is None
True</code></pre>
<p>La mutiplication dâ€™une liste par un entier <code>n</code> est
Ã©galement dÃ©finie : elle produit <code>n</code> copies de la liste
initiale qui sont concatÃ©nÃ©es.</p>
<pre class="python"><code>&gt;&gt;&gt; 3 * [7, 1]
[7, 1, 7, 1, 7, 1]</code></pre>
<p>La boucle <code>for</code> permet dâ€™itÃ©rer sur tous les Ã©lÃ©ments
dâ€™une liste.</p>
<pre class="python"><code>&gt;&gt;&gt; l = [1, 2, 3, 4]
&gt;&gt;&gt; len(l)
4
&gt;&gt;&gt; for i in l:
...     print(i)
...
1
2
3
4</code></pre>
<p>Une sÃ©quence dâ€™ entiers entre <code>0</code> et <code>n-1</code> est
produite par <code>range(n)</code>. Ce nâ€™est toutefois pas une liste
classique, mais une liste paresseuse, dont les valeurs sont produites Ã 
la demande, ce qui permet dâ€™Ã©conomiser de la mÃ©moire. On peut nÃ©anmoins
la convertir sans difficultÃ© en une liste classique si le besoin sâ€™en
fait sentir.</p>
<pre class="python"><code>&gt;&gt;&gt; for i in range(5):
...     print(i)
...
0
1
2
3
4
&gt;&gt;&gt; range(5)
range(0, 5)
&gt;&gt;&gt;
&gt;&gt;&gt; list(range(5))
[0, 1, 2, 3, 4]</code></pre>
<p>âš ï¸ Attention aux listes partageant des objets modifiables â€¦ par
exemple des listes ! Ce sont les rÃ©fÃ©rences aux objets qui sont stockÃ©s
dans les listes, pas les objets eux-mÃªmes ; en modifiant un Ã©lÃ©ment
dâ€™une liste, on modifie donc Ã©galement toute liste dont il est
Ã©lÃ©ment.</p>
<pre class="python"><code>&gt;&gt;&gt; l = [[1, 2], [3, 4]]
&gt;&gt;&gt; elt = l[0]
&gt;&gt;&gt; elt
[1, 2]
&gt;&gt;&gt; elt.append(42)
&gt;&gt;&gt; elt
[1, 2, 42]
&gt;&gt;&gt; l
[[1, 3, 42], [3, 4]]</code></pre>
<h1 id="dictionnaires">Dictionnaires</h1>
<p>Les <strong>dictionnaires</strong> (ğŸ‡ºğŸ‡¸ <strong>dictionaries</strong>)
Python sont des structures de donnÃ©es qui associent Ã  des clÃ©s (ğŸ‡ºğŸ‡¸
<strong>keys</strong>) des valeurs (ğŸ‡ºğŸ‡¸ <strong>values</strong>). On
parle dans dâ€™autre langages de tableaux associatifs (ğŸ‡ºğŸ‡¸
<strong>associative arrays</strong>) ou en rÃ©fÃ©rence Ã  leur
implÃ©mentation, de <strong>tables de hachage</strong> (ğŸ‡ºğŸ‡¸ <strong>hash
tables</strong>).</p>
<p>Le dictionnaire Python reprÃ©sentant les associations suivantes</p>
<table style="width:33%;">
<colgroup>
<col style="width: 9%"/>
<col style="width: 11%"/>
<col style="width: 12%"/>
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">clÃ©</th>
<th style="text-align: center;"><span class="math inline">\(\to\)</span></th>
<th style="text-align: center;">valeur</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>"a"</code></td>
<td style="text-align: center;"><span class="math inline">\(\to\)</span></td>
<td style="text-align: center;"><code>1</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>"b"</code></td>
<td style="text-align: center;"><span class="math inline">\(\to\)</span></td>
<td style="text-align: center;"><code>2</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>"c"</code></td>
<td style="text-align: center;"><span class="math inline">\(\to\)</span></td>
<td style="text-align: center;"><code>3</code></td>
</tr>
</tbody>
</table>
<p>peut Ãªtre dÃ©fini par lâ€™instruction</p>
<pre class="python"><code>&gt;&gt;&gt; d = {"a": 1, "b": 2, "c": 3}</code></pre>
<p>Les donnÃ©es dâ€™un dictionaire peuvent Ãªtre lues, Ã©crites et effacÃ©es
:</p>
<pre class="python"><code>&gt;&gt;&gt; d["a"]
1
&gt;&gt;&gt; d
{'a': 1, 'b': 2, 'c': 3}
&gt;&gt;&gt; d["d"] = 4
&gt;&gt;&gt; d
{'a': 1, 'b': 2, 'c': 3, 'd': 4}
&gt;&gt;&gt; del d["a"]
&gt;&gt;&gt; d
{'b': 2, 'c': 3, 'd': 4}</code></pre>
<p>AccÃ©der Ã  une clÃ© manquante avec la notation <code>[]</code> gÃ©nÃ¨re
une erreur</p>
<pre class="python"><code>&gt;&gt;&gt; d["a"]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'a'</code></pre>
<p>mais la mÃ©thode <code>get</code> des dictionnaires permet de renvoyer
la valeur associÃ©e Ã  la clÃ© demandÃ©e si la clÃ© est prÃ©sente et
<code>None</code> dans le cas contraire.</p>
<pre class="python"><code>&gt;&gt;&gt; d.get("b")
2
&gt;&gt;&gt; d.get("a")</code></pre>
<p>On peut Ã©galement spÃ©cifier une autre valeur de repli que
<code>None</code> si besoin :</p>
<pre class="python"><code>&gt;&gt;&gt; d.get("b", 0)
2
&gt;&gt;&gt; d.get("a", 0)
0</code></pre>
<p>Pour les dictionnaires, les tests dâ€™appartenance et lâ€™itÃ©ration ne
concernent que les clÃ©s et pas les valeurs :</p>
<pre class="python"><code>&gt;&gt;&gt; "a" in d
False
&gt;&gt;&gt; "b" in d
True
&gt;&gt;&gt; for k in d:
...     print(k)
... 
b
c
d
&gt;&gt;&gt; list(d)
['b', 'c', 'd']</code></pre>
<p>Cela nâ€™est toutefois que le comportement par dÃ©faut : les mÃ©thodes
<code>keys</code>, <code>values</code> et <code>items</code> permettent
de choisir plus prÃ©cisÃ©ment sur quels objets du dictionnaire on souhaite
itÃ©rer.</p>
<pre class="python"><code>&gt;&gt;&gt; for k in d.keys():
...     print(k)
... 
b
c
d
&gt;&gt;&gt; list(d.keys())
['b', 'c', 'd']</code></pre>
<pre class="python"><code>&gt;&gt;&gt; for v in d.values():
...     print(v)
... 
2
3
4
&gt;&gt;&gt; list(d.values())
[2, 3, 4]</code></pre>
<pre class="python"><code>&gt;&gt;&gt; for k, v in d.items():
...     print(k, v)
... 
b 2
c 3
d 4
&gt;&gt;&gt; list(d.items())
[('b', 2), ('c', 3), ('d', 4)]</code></pre>
<p>Il existe des mÃ©thodes dâ€™importance moindre qui sont parfois utiles.
Par exemple <code>update</code> permet dâ€™ajouter / modifier plusieurs
associations clÃ©s-valeurs Ã  un dictionnaire ou <code>pop</code> qui
permet de lire la valeur associÃ©e Ã  une clÃ© avant de la retirer du
dictionnaire.</p>
<pre class="python"><code>&gt;&gt;&gt; d
{'b': 2, 'c': 3, 'd': 4}
&gt;&gt;&gt; d.update({"e": 5, "f": 6})
&gt;&gt;&gt; d
{'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}
&gt;&gt;&gt; d.pop("b")
2
&gt;&gt;&gt; d
{'c': 3, 'd': 4, 'e': 5, 'f': 6}</code></pre>
<p>La palme de la complexitÃ© revient Ã  lâ€™infÃ¢me mÃ©thode
<code>setdefault</code> dont la description est la suivante :</p>
<blockquote>
<p><code>setdefault(d, key, default=None)</code></p>
<p>Insert <code>key</code> in the dictionary <code>d</code> with a value
of <code>default</code> if key is not in <code>d</code>.</p>
<p>Return the value for key if key is in the dictionary, else
default.</p>
</blockquote>
<p>Plus important : les clÃ©s ne sont pas nÃ©cessairement des chaÃ®nes de
caractÃ¨res ou les valeurs des nombres :</p>
<pre class="python"><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; {math.pi: 90.0}
{3.141592653589793: 90.0}
&gt;&gt;&gt; {1: 4.0, 2.0: 8, False: "yep"}
{1: 4.0, 2.0: 8, False: 'yep'}
&gt;&gt;&gt; {(1, 2): 7, (7, 8, 9): 9}
{(1, 2): 7, (7, 8, 9): 9}
&gt;&gt;&gt; {(1, ("aa", "bb")): 90}
{(1, ('aa', 'bb')): 90}</code></pre>
<p>Il nâ€™y a en fait aucune restriction sur le type des valeurs que vous
pouvez stocker dans un dictionnaire. Par contre, les clÃ©s doivent Ãªtre
<strong>hachable</strong> (ğŸ‡ºğŸ‡¸ <strong>hashable</strong>), ce qui nâ€™est
par exemple pas le cas des listes :</p>
<pre class="python"><code>&gt;&gt;&gt; {[2]: 90.0}
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
&gt;&gt;&gt; hash([2])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'</code></pre>
<p>Câ€™est le cas de la plupart des types atomiques immuables de
Python</p>
<pre class="python"><code>&gt;&gt;&gt; hash(None)
5891579141320
&gt;&gt;&gt; hash(False)
0
&gt;&gt;&gt; hash(42)
42
&gt;&gt;&gt; hash(math.pi)
326490430436040707
&gt;&gt;&gt; hash("Hello!")
3339764772054024462</code></pre>
<p>ainsi que des <a href="#n-uplets">N-uplets</a> eux-mÃªmes composÃ©s
dâ€™objets hashables</p>
<pre class="python"><code>&gt;&gt;&gt; hash((None, False, 42, math.pi, "Hello!"))
&gt;&gt;&gt; hash((0, (1, (2, (3, ())))))
&gt;&gt;&gt; hash((1, 2, [3]))
&gt;&gt;&gt; hash((1, 2, [3]))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'</code></pre>
<details>
<summary>
<strong>Pourquoi cette restriction ? ğŸ¤”</strong>
</summary>
Pour des raisons de performance ! En effet les tables de hachage
permettent (sous certains hypothÃ¨ses) dâ€™accÃ©der aux valeurs en un temps
qui ne dÃ©pend pas du nombre dâ€™Ã©lÃ©ments dans la structure, cf.Â par
exemple <a href="https://fr.wikipedia.org/wiki/Table_de_hachage">lâ€™article
WikipÃ©dia qui y est consacrÃ©</a>. A lâ€™inverse, lâ€™implÃ©mentation des
tableaux associatifs dans une structure plus simple, comme la liste de
liste <code>[["a", 1], ["b": 2], ["c": 3]]</code> conduirait Ã  une
augmentation du temps dâ€™accÃ¨s croissant linÃ©airement avec le nombre
dâ€™Ã©lements dans la structure.
</details>
<h1 id="n-uplets">N-uplets</h1>
<p>Les n-uplets sont souvent utilisÃ©s de faÃ§on implicite, pour concevoir
une fonction renvoyant plusieurs valeurs ou pour affecter en une
instruction unique plusieurs variables.</p>
<pre class="python"><code>&gt;&gt;&gt; def compute_pi():
...     value = 3.14
...     error = 0.005
...     return value, error
... 
&gt;&gt;&gt; value, error = compute_pi()
&gt;&gt;&gt; print(f"{value} Â± {error}")
3.14 Â± 0.005</code></pre>
<pre class="python"><code>&gt;&gt;&gt; a = 1
&gt;&gt;&gt; b = 2
&gt;&gt;&gt; c = 3
&gt;&gt;&gt; a, b = b, c
&gt;&gt;&gt; a
2
&gt;&gt;&gt; b
3</code></pre>
<p>Lâ€™instruction <code>value, error = compute_pi()</code> produit en
fait une paire (un n-uplet de longueur 2) qui est instantanÃ©ment
<strong>destructurÃ©</strong> pour fournir des valeurs aux variables
<code>value</code> et <code>error</code>. Cela devient beaucoup plus
Ã©vident si lâ€™on dÃ©compose ces Ã©tapes :</p>
<pre class="python"><code>&gt;&gt;&gt; value_and_error = compute_pi()
&gt;&gt;&gt; value_and_error
(3.14, 0.005)
&gt;&gt;&gt; type(value_and_error)
&lt;class 'tuple'&gt;
&gt;&gt;&gt; len(value_and_error)
2
&gt;&gt;&gt; value, error = value_and_error
&gt;&gt;&gt; value
3.14
&gt;&gt;&gt; error
0.005</code></pre>
<p>Quant Ã  lâ€™affectation <code>a, b = b, c</code>, elle passe aussi
implicitement par la crÃ©ation dâ€™une paire : elle Ã©quivaut Ã </p>
<pre class="python"><code>&gt;&gt;&gt; b_and_c = b, c
&gt;&gt;&gt; b_and_c
(2, 3)
&gt;&gt;&gt; type(b_and_c)
&lt;class 'tuple'&gt;
&gt;&gt;&gt; len(b_and_c)
2
&gt;&gt;&gt; a, b = b_and_c
&gt;&gt;&gt; a
2
&gt;&gt;&gt; b
3</code></pre>
<p>Si nous avons pu oublier quâ€™un tuple Ã©tait crÃ©e, câ€™est quâ€™un tuple
peut le plus souvent Ãªtre dÃ©fini par une notation trÃ¨s lÃ©gÃ¨re, avec une
suite dâ€™objets sÃ©parÃ©s par des virgules. Mais la notation
universellement valide des tuples met entre parenthÃ¨ses cette suite. Au
lieu du code initial, nous aurions trÃ¨s bien pu Ã©crire</p>
<pre class="python"><code>&gt;&gt;&gt; def compute_pi():
...     value = 3.14
...     error = 0.005
...     return (value, error)
... 
&gt;&gt;&gt; (value, error) = compute_pi()
&gt;&gt;&gt; print(f"{value} Â± {error}")
3.14 Â± 0.005</code></pre>
<pre class="python"><code>&gt;&gt;&gt; a = 1
&gt;&gt;&gt; b = 2
&gt;&gt;&gt; c = 3
&gt;&gt;&gt; (a, b) = (b, c)
&gt;&gt;&gt; a
2
&gt;&gt;&gt; b
3</code></pre>
<p>ce qui est Ã©quivalent, mais plus explicite. Le tuple vide est
dâ€™ailleurs dÃ©signÃ© par la notation <code>()</code> ; pour un n-uplet de
longueur 0 contenant par exemple lâ€™unique argument 1, on serait tentÃ©
dâ€™utiliser la notation <code>(1)</code> mais il y aurait alors une
ambiguitÃ© dans les notations car les parenthÃ¨ses sont aussi utilisÃ©es
pour indiquer des prioritÃ©s entre opÃ©rations dans les calculs. Il faut
donc se rÃ©signer Ã  adopter une <strong>virgule finale</strong> (ğŸ‡ºğŸ‡¸
<strong>trailing comma</strong>) et utiliser la notation
<code>(1,)</code>. On peut conserver la virgule finale pour les n-uplets
de longueur 2 ou plus, mais elle nâ€™est plus nÃ©cessaire.</p>
<pre class="python"><code>&gt;&gt;&gt; ()
()
&gt;&gt;&gt; (1) # âš ï¸ not a tuple!
1
&gt;&gt;&gt; (1,)
(1,)
&gt;&gt;&gt; 1,
&gt;&gt;&gt; (1, 2)
(1, 2)
&gt;&gt;&gt; (1, 2,)
(1, 2)
&gt;&gt;&gt; 1, 2
(1, 2)
&gt;&gt;&gt; 1, 2,
(1, 2)</code></pre>
<p>Les n-uplets sont immuables : de longueur fixe et dont les Ã©lements
ne peuvent Ãªtre remplacÃ©s.</p>
<pre class="python"><code>&gt;&gt;&gt; t = (1, 2)
&gt;&gt;&gt; t[0]
1
&gt;&gt;&gt; t[1]
2
&gt;&gt;&gt; t[0] = 3
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'tuple' object does not support item assignment</code></pre>
<p>NÃ©anmoins cette immuabilitÃ© est superficielle : si un n-uplet
contient une valeur modifiable (comme une liste), il est toujours
possible de modifier la liste et donc de modifier
<strong>indirectement</strong> le n-uplet.</p>
<pre class="python"><code>&gt;&gt;&gt; l = [1, 2, 3]
&gt;&gt;&gt; t = (l, 2, 3, 3)
&gt;&gt;&gt; t
([1, 2, 3], 2, 3, 3)
&gt;&gt;&gt; l.append(42)
&gt;&gt;&gt; t
([1, 2, 3, 42], 2, 3, 3)</code></pre>
<h1 id="ensembles">Ensembles</h1>
<p>Un ensemble peut Ãªtre dÃ©fini par une suite dâ€™objets sÃ©parÃ©s par des
virgules et entourÃ©e par des accolades</p>
<pre class="python"><code>&gt;&gt;&gt; {1, 2, 3, 4}
{1, 2, 3, 4}</code></pre>
<p>Il est Ã©galement possible de passer par le constructeur
<code>set</code> avec une une liste comme argument</p>
<pre class="python"><code>&gt;&gt;&gt; set([1, 2, 3, 4])
{1, 2, 3, 4}</code></pre>
<p>Inversement, il est aisÃ© de convertir un ensemble en liste</p>
<pre class="python"><code>&gt;&gt;&gt; list({1, 2, 3, 4})
[1, 2, 3, 4]</code></pre>
<p>âš ï¸ La notation <code>{}</code> ne dÃ©finit pas un ensemble vide, mais
un dictionnaire vide<a class="footnote-ref" href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Lâ€™ensemble vide peut Ãªtre dÃ©fini
par <code>set()</code>.</p>
<pre class="python"><code>&gt;&gt;&gt; type({})
&lt;class 'dict'&gt;
&gt;&gt;&gt; set()
set()</code></pre>
<p>Lâ€™implÃ©mentation dâ€™un ensemble est similaire Ã  celle dâ€™un
dictionnaire qui auraient les Ã©lements de lâ€™ensemble comme clÃ©s et (par
exemple) <code>True</code> comme valeur commune Ã  toutes les clÃ©s.</p>
<pre class="python"><code>&gt;&gt;&gt; s = {1, 2, 3, 4}
&gt;&gt;&gt; d = {1: True, 2: True, 3: True, 4: True}</code></pre>
<p>Cela permet de comprendre pourquoi les Ã©lements rÃ©pÃ©tÃ©s dâ€™un ensemble
sont ignorÃ©s et pourquoi bien que lâ€™ordre dâ€™insertion des Ã©lÃ©ments soit
prÃ©servÃ©, cet ordre ne rentre pas en ligne de compte dans les
comparaisons</p>
<pre class="python"><code>&gt;&gt;&gt; {1, 2, 2, 3, 3, 3, 4, 4, 4, 4}
{1, 2, 3, 4}
&gt;&gt;&gt; {4, 3, 2, 1}
{4, 3, 2, 1}
&gt;&gt;&gt; {1, 2, 3, 4} == {4, 3, 2, 1}
True</code></pre>
<p>Sans surprise, on peut Ã©galement en dÃ©duire que seuls les objets
hashables peuvent Ãªtre utilisÃ©s comme Ã©lÃ©ments dâ€™un ensemble.</p>
<pre class="python"><code>&gt;&gt;&gt; s = {1, 2, "djksjds", (2, 3), (2, ("jsdksjk", 90))}
&gt;&gt;&gt; s = {[]}
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'</code></pre>
<p>Les ensembles sont modifiables : il est possible dâ€™ajouter des
Ã©lÃ©ments Ã  un ensemble et dâ€™en retirer. Il est Ã©galement possible de
tester si un objet appartient Ã  lâ€™ensemble et dâ€™itÃ©rer sur les Ã©lÃ©ments
de lâ€™ensemble.</p>
<pre class="python"><code>&gt;&gt;&gt; s = {1, 2, "djksjds", (2, 3), (2, ("jsdksjk", 90))}
&gt;&gt;&gt; s.add(42)
&gt;&gt;&gt; s
{(2, ('jsdksjk', 90)), 1, 2, (2, 3), 'djksjds', 42}
&gt;&gt;&gt; s.remove(42)
&gt;&gt;&gt; s
{(2, ('jsdksjk', 90)), 1, 2, (2, 3), 'djksjds'}
&gt;&gt;&gt; 1 in s
True
&gt;&gt;&gt; for x in s:
...     print(x)
... 
(2, ('jsdksjk', 90))
1
2
(2, 3)
djksjds</code></pre>
<p>Les opÃ©ration ensemblistes classiques sont supportÃ©es par des
opÃ©rateurs :</p>
<table style="width:74%;">
<colgroup>
<col style="width: 33%"/>
<col style="width: 18%"/>
<col style="width: 22%"/>
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">OpÃ©ration ensembliste</th>
<th style="text-align: center;">Symbole</th>
<th style="text-align: center;">OpÃ©rateur</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Union</td>
<td style="text-align: center;"><span class="math inline">\(\cup\)</span></td>
<td style="text-align: center;"><code>|</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Intersection</td>
<td style="text-align: center;"><span class="math inline">\(\cap\)</span></td>
<td style="text-align: center;"><code>&amp;</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">DiffÃ©rence</td>
<td style="text-align: center;"><span class="math inline">\(\setminus\)</span></td>
<td style="text-align: center;"><code>-</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">DiffÃ©rence symmÃ©trique</td>
<td style="text-align: center;"><span class="math inline">\(\Delta\)</span></td>
<td style="text-align: center;"><code>^</code></td>
</tr>
</tbody>
</table>
<p>Ainsi, avec</p>
<pre class="python"><code>&gt;&gt;&gt; s1 = {1, 2, 3, 4, 5}
&gt;&gt;&gt; s2 = {4, 5, 6, 7, 8}</code></pre>
<p>on obtient</p>
<pre class="python"><code>&gt;&gt;&gt; s1 | s2
{1, 2, 3, 4, 5, 6, 7, 8}
&gt;&gt;&gt; s1 &amp; s2
{4, 5}
&gt;&gt;&gt; s1 - s2
{1, 2, 3}
&gt;&gt;&gt; s1 ^ s2
{1, 2, 3, 6, 7, 8}</code></pre>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr/>
<ol>
<li id="fn1" role="doc-endnote"><p>Les dictionnaires existaient dans
Python bien avant que les ensembles ne soient introduits. Ils ont donc
exploitÃ© les premiers la notation <code>{}</code> et les ensembles ont
dÃ» sâ€™en accomoder a posteriori.<a class="footnote-back" href="#fnref1" role="doc-backlink">â†©ï¸</a></p></li>
</ol>
</section>
</body>
</html>
