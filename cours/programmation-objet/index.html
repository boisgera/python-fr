<!DOCTYPE html>

<html lang="fr" xml:lang="fr" xmlns="http://www.w3.org/1999/xhtml">
<head>
<script>
        window.MathJax = {
          tex: {
            tags: 'ams'
          }
        };
       </script>

<meta charset="utf-8"/>
<meta content="pandoc" name="generator"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport"/>
<meta content="S√©bastien Boisg√©rault, MINES Paris, Universit√© PSL" name="author"/>
<title>Programmation Orient√©e Objet</title>
<style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
<link href="css/style.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&amp;display=swap" rel="stylesheet"/>
<script>

      function filterConsole(text) {
          let lines = text.split("\n");

          console.log(lines);

          let pythonConsole = lines && lines[0].startsWith(">>>");
          if (!pythonConsole) {
              return text + "\n\n";
          } else {
              let newLines = [];
              for (let line of lines) {
                  if (line.startsWith(">>> ") || line.startsWith("... ")) {
                      newLines.push(line.slice(4));
                  } else if (line.startsWith("...")){
                      newLines.push(line.slice(3));
                  }

              }
              return newLines.join("\n") + "\n";
          }

      }

      document.addEventListener("DOMContentLoaded", (event) => {
          let codeBlocks = document.querySelectorAll("pre.python")
          for (let codeBlock of codeBlocks) {

              let button = document.createElement("button")
              let icon = document.createElement("img");
              button.appendChild(icon)
              codeBlock.insertBefore(button, codeBlock.firstChild);

              icon.setAttribute("src", "icons/copy.svg");
              icon.setAttribute("style", "opacity: 0.5;")
              button.addEventListener('click', (event) => {
                  let text = button.nextElementSibling.textContent;
                  text = filterConsole(text);
                  navigator.clipboard.writeText(text);
              });

              codeBlock.setAttribute("style", "position: relative");
              button.setAttribute("style", 
              "position: absolute; right: 1em; top: 1em; opacity: 0.0;");

              codeBlock.addEventListener("mouseover", (event) => {
                  button.style.setProperty("transition", "opacity 0.1s ease-out");
                  button.style.setProperty("opacity", "1.0");
              });

              codeBlock.addEventListener("mouseout", (event) => {
                  button.style.setProperty("transition", "opacity 0.75s ease-out");
                  button.style.setProperty("opacity", "0.0");
              });

              button.addEventListener("mouseover", (event) => {
                  icon.style.setProperty("transition", "opacity 0.1s ease-out");
                  icon.style.setProperty("opacity", "0.75");
              })

              button.addEventListener("mouseout", (event) => {
                  icon.style.setProperty("transition", "opacity 0.75s ease-out");
                  icon.style.setProperty("opacity", "0.5");
              })


          }
      });    
  </script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
<!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Programmation Orient√©e Objet</h1>
<p class="author"><a href="mailto:Sebastien.Boisgerault@minesparis.psl.eu">S√©bastien
Boisg√©rault</a>, MINES Paris, Universit√© PSL</p>
<p class="date">Dimanche 15 mai 2022</p>

<p>
<span style="display:inline-block;width:1em;position:relative;margin-right:0.25em">
<img height="auto" src="icons/github.svg" style="position:relative;top:0.15em;" width="100%"/>
</span>
<a href="https://github.com/boisgera/python-fr">
          https://github.com/boisgera/python-fr
        </a>
</p>

<p>
<span style="display:inline-block;width:1em;position:relative;margin-right:0.25em">
<img height="auto" src="icons/git.svg" style="position:relative;top:0.15em;" width="100%"/>
</span>
<a href="https://github.com/boisgera/python-fr/commit/4ff5698">
          #4ff5698
        </a>
</p>

<p>
<span style="display:inline-block;width:1em;position:relative;margin-right:0.25em">
<img height="auto" src="icons/edit.svg" style="position:relative;top:0.15em;" width="100%"/>
</span>
<a href="https://github.com/boisgera/python-fr/edit/master/cours/programmation-objet/index.md">
          Edition
        </a>
</p>
</header>
<details>
<summary>
<h2>Table des mati√®res</h2>
</summary>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#usage-des-objets" id="toc-usage-des-objets">Usage des
objets</a>
<ul>
<li><a href="#des-objets-partout" id="toc-des-objets-partout">Des objets
partout !</a></li>
<li><a href="#des-nombres-pas-si-complexes" id="toc-des-nombres-pas-si-complexes">Des nombres pas si
complexes</a></li>
</ul></li>
<li><a href="#conception-de-types" id="toc-conception-de-types">Conception de types</a>
<ul>
<li><a href="#constructeur-attributs" id="toc-constructeur-attributs">Constructeur &amp; Attributs</a></li>
<li><a href="#m√©thodes-1" id="toc-m√©thodes-1">M√©thodes</a></li>
<li><a href="#m√©thodes-magiques-1" id="toc-m√©thodes-magiques-1">M√©thodes
magiques</a></li>
<li><a href="#attributs-priv√©s" id="toc-attributs-priv√©s">Attributs
priv√©s</a></li>
<li><a href="#propri√©t√©s" id="toc-propri√©t√©s">Propri√©t√©s</a></li>
</ul></li>
<li><a href="#objectification-examples" id="toc-objectification-examples">Objectification (Examples)</a></li>
</ul>
</nav></details>


<h1 id="usage-des-objets">Usage des objets</h1>
<h2 id="des-objets-partout">Des objets partout !</h2>
<p>Avant de d√©couvrir comment utiliser les objets, il est bon de se
convaincre que cette comp√©tence sera tr√®s utile en Python, car :</p>
<blockquote>
<p>Tout ce qui peut √™tre d√©sign√© par une variable est un objet !</p>
</blockquote>
<p>Techniquement : ‚Äúest une <strong>instance</strong> du type
<code>object</code>‚Äù.</p>
<details>
<summary>
<h4 id="instance">Instance ?</h4>
</summary>
<p>Un terme √† interpr√©ter dans sa version anglo-saxonne o√π il peut
signifier ‚Äúan individual illustrative of a category‚Äù. On pourra se
repr√©senter un <strong>type</strong> comme une collection d‚Äô√©l√©ments :
ses instances.</p>
<hr/>
</details>
<p>Entiers, bool√©ens, cha√Ænes de caract√®re, listes, sont donc des objets
:</p>
<pre class="python"><code>&gt;&gt;&gt; isinstance(42, object)
True
&gt;&gt;&gt; isinstance(True, object)
True
&gt;&gt;&gt; isinstance("Hello!", object)
True
&gt;&gt;&gt; isinstance([1, 2, 3], object)
True</code></pre>
<details>
<summary>
<h4 id="alors-42-serait-un-objet-pas-un-entier">ü§î Alors <code>42</code>
serait un objet, pas un entier?</h4>
</summary>
<p>Mais si car les deux sont possibles simultan√©ment ! Nous avons d√©j√†
constat√© que <code>42</code> √©tait bien un objet :</p>
<pre class="python"><code>&gt;&gt;&gt; isinstance(42, object)
True</code></pre>
<p>V√©rifions que c‚Äôest √©galement un entier :</p>
<pre class="python"><code>&gt;&gt;&gt; isinstance(42, int)
True</code></pre>
<p>Donc les deux propri√©t√©s ne sont pas contradictoires. Plus
pr√©cis√©ment, le type de <code>42</code> est entier, pas objet :</p>
<pre class="python"><code>&gt;&gt;&gt; type(42) == int
True</code></pre>
<p>mais comme entier est un sous-type d‚Äôobjet</p>
<pre class="python"><code>&gt;&gt;&gt; issubclass(int, object)
True</code></pre>
<p>tous les entiers sont aussi des objets.</p>
<hr/>
</details>
<p>Bien que cela soit peut-√™tre moins intuitif, des fonctions, des types
ou des modules sont aussi des objets :</p>
<pre class="python"><code>&gt;&gt;&gt; isinstance(print, object)
True 
&gt;&gt;&gt; isinstance(int, object)
True
&gt;&gt;&gt; import sys; isinstance(sys, object)
True</code></pre>
<h2 id="des-nombres-pas-si-complexes">Des nombres pas si complexes</h2>
<p>Le type <code>complex</code> repr√©sente en Python les nombres
complexes. Il fournit un bon example des interactions qu‚Äôon peut avoir
avec des objets.</p>
<h3 id="construction">Construction</h3>
<p>Pour cr√©er le nombre complexe <span class="math inline">\(z = 1/2 +
(3/2)i\)</span>, on peut utiliser la notation lit√©rale pour les nombres
complexes :</p>
<pre class="python"><code>&gt;&gt;&gt; z = 0.5 + 1.5j</code></pre>
<p>Il est bon de conna√Ætre cette syntaxe car c‚Äôest celle que Python
utilisera pour repr√©senter les nombres complexes:</p>
<pre class="python"><code>&gt;&gt;&gt; z
(0.5+1.5j)</code></pre>
<p>N√©anmoins tous les objets ne sont pas dot√©s d‚Äôune telle notation.
Mais il existe une m√©thode alternative pour tous les objets : on peut
appeler le type de l‚Äôobjet que l‚Äôon souhaite instancier (comme s‚Äôil
√©tait une fonction) en lui passant les arguments n√©cessaires, ici partie
r√©elle et imaginaire du nombre √† construire. Le type de l‚Äôobjet sert
donc de <strong>constructeur</strong>.</p>
<pre class="python"><code>&gt;&gt;&gt; z = complex(0.5, 1.5)
&gt;&gt;&gt; z == 0.5+1.5j
True</code></pre>
<h3 id="attributs">Attributs</h3>
<p>Un objet est une structure de donn√©es. Les donn√©es qu‚Äôil contient
peuvent √™tre rendus accessible sous forme d‚Äô<strong>attributs</strong>.
Tous nombres complexes poss√®dent ainsi les attributs <code>real</code>
et <code>imag</code> :</p>
<pre class="python"><code>&gt;&gt;&gt; z.real
0.5
&gt;&gt;&gt; z.imag
1.5</code></pre>
<p>La syntaxe pour changer la valeur de l‚Äôattribut <code>real</code> du
nombre <code>z</code> devrait √™tre <code>z.real = ...</code>. Ici
toutefois un tel assignement √©choue parce que les nombres complexes sont
(volontairement) immuables.</p>
<pre class="python"><code>&gt;&gt;&gt; z.real = -0.5
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: readonly attribute</code></pre>
<h3 id="m√©thodes">M√©thodes</h3>
<p>Un nombre complexe poss√®de un attribut <code>conjugate</code> dont la
nature est un peu particuli√®re, une <strong>m√©thode</strong> :</p>
<pre class="python"><code>&gt;&gt;&gt; z.conjugate #doctest: +ELLIPSIS
&lt;built-in method conjugate of complex object at 0x...&gt;</code></pre>
<p>Les m√©thodes, qui se comportent comme les fonctions, sont appelables
:</p>
<pre><code>&gt;&gt;&gt; callable(z.conjugate)
True</code></pre>
<p>Cette m√©thode est <strong>li√©e</strong> au nombre complexe
<code>z</code> : elle peut utiliser <code>z</code> et les donn√©es qu‚Äôil
contient pour produire un r√©sultat, sans qu‚Äôil soit n√©cessaire de lui
passer explicitement <code>z</code> comme argument. Ici,
<code>z.conjugate()</code> renvoie le nombre complexe conjug√© de
<code>z</code>:</p>
<pre class="python"><code>&gt;&gt;&gt; z.conjugate()
(0.5-1.5j)</code></pre>
<p>La m√©thode <code>conjugate</code> est √©galement disponible comme
attribut du type <code>complex</code>:</p>
<pre class="python"><code>&gt;&gt;&gt; complex.conjugate
&lt;method 'conjugate' of 'complex' objects&gt;</code></pre>
<p>Elle n‚Äôest alors par li√©e √† une instance particuli√®re de nombre
complexe ; il faudra donc lui fournir explicitement le nombre complexe √†
conjuguer en argument :</p>
<pre class="python"><code>&gt;&gt;&gt; complex.conjugate(z)
(0.5-1.5j)</code></pre>
<h3 id="m√©thodes-magiques">M√©thodes magiques</h3>
<p>Sont <strong>magiques</strong> les m√©thodes d‚Äôun objet dont le nom
commence et finit par un double soulignement <code>"__"</code>. Ces
m√©thodes magiques sont rarement appel√©es directement par le programmeur,
mais indirectement par Python lui-m√™me.</p>
<p>Les m√©thodes magiques du type <code>complex</code> permettent par
exemple de faire des calculs avec des nombres complexes avec une syntaxe
concise : s‚Äôil est possible de calculer</p>
<pre class="python"><code>&gt;&gt;&gt; 1j + 1j * 1j
(-1+1j)</code></pre>
<p>c‚Äôest que le type complex comporte les m√©thodes magiques
<code>__add__</code> et <code>__mul__</code>, appel√©es en cas d‚Äôaddition
et de multiplication respectivement. Le calcul ci-dessus est donc
√©quivalent √† :</p>
<pre class="python"><code>&gt;&gt;&gt; complex.__add__(1j, complex.__mul__(1j, 1j))
(-1+1j)</code></pre>
<p>ou bien, en utilisant la version li√©e de ces m√©thodes :</p>
<pre class="python"><code>&gt;&gt;&gt; 1j.__add__(1j.__mul__(1j))
(-1+1j)</code></pre>
<p>Dans tous les cas, la notation initiale ‚Äì o√π l‚Äôon laisse le soin √†
Python d‚Äôappeler lui-m√™me les m√©thodes magiques ‚Äì est sensiblement plus
lisible !</p>
<h1 id="conception-de-types">Conception de types</h1>
<p>Notre objectif dans cette section va √™tre de cr√©er un type
<code>Complex</code> qui va √™tre une version simplifi√© du type int√©gr√©
<code>complex</code>. Nous allons pour cela d√©finir une nouvelle
<strong>classe</strong>; pour cr√©er une classe minimale, sans
fonctionnalit√© sp√©cifique, le code ci-dessous suffit :</p>
<pre class="python"><code>class Complex:
    pass</code></pre>
<p>A ce stade, il est certe possible d‚Äôinstancier un ‚Äúnombre
complexe‚Äù</p>
<pre class="python"><code>&gt;&gt;&gt; z = Complex()</code></pre>
<p>ayant le bon type</p>
<pre class="python"><code>&gt;&gt;&gt; type(z) is Complex
True
&gt;&gt;&gt; isinstance(z, Complex)
True</code></pre>
<p>mais il n‚Äôest dot√© d‚Äôaucun attribut ou m√©thode caract√©ristique des
nombres complexes</p>
<pre class="python"><code>&gt;&gt;&gt; z.real
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Complex' object has no attribute 'real'
&gt;&gt;&gt; z.conjugate()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Complex' object has no attribute 'conjugate'
&gt;&gt;&gt; z + z
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'Complex' and 'Complex'</code></pre>
<h2 id="constructeur-attributs">Constructeur &amp; Attributs</h2>
<p>Pour g√©rer l‚Äôajout des attributs <code>real</code> et
<code>imag</code>, on pourrait d√©finir une fonction</p>
<pre class="python"><code>def Complex_init(z, real, imag):
    z.real = real
    z.imag = imag</code></pre>
<p>qui nous permettrait de prendre un nombre complexe vide et d‚Äôy
ajouter les attributs souhait√©s :</p>
<pre class="python"><code>&gt;&gt;&gt; z = Complex()
&gt;&gt;&gt; Complex_init(z, 0.5, 1.5)
&gt;&gt;&gt; z.real
0.5
&gt;&gt;&gt; z.imag
1.5</code></pre>
<p>Possible oui, mais pas pratique ! En d√©finissant directement la
fonction pr√©c√©dente dans la classe <code>Complex</code>, et en la
nommant <code>__init__</code>, on d√©finit une m√©thode magique qui est le
constructeur associ√© √† la classe <code>Complex</code> et on s‚Äô√©vite cet
usage maladroit.</p>
<p>En adoptant la d√©finition suivante de <code>Complex</code></p>
<pre class="python"><code>class Complex:
    def __init__(z, real, imag):
        z.real = real
        z.imag = imag</code></pre>
<p>on peut s‚Äô√©pargner la cr√©ation d‚Äôun objet sans attributs, pris
automatiquement en charge quand on appelle le constructeur de nombres
complexes</p>
<pre class="python"><code>&gt;&gt;&gt; z = Complex(0.5, 1.5)
&gt;&gt;&gt; z.real
0.5
&gt;&gt;&gt; z.imag
1.5</code></pre>
<p>L‚Äôusage quand une telle m√©thode est d√©finie est d‚Äôappeler
<code>self</code> le premier argument de la m√©thode, qui d√©signera
toujours une instance de la classe consid√©r√©e</p>
<pre class="python"><code>class Complex:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag</code></pre>
<p>C‚Äôest uniquement une convention, qui ne change rien au comportement
de la classe que nous avions d√©finie.</p>
<h2 id="m√©thodes-1">M√©thodes</h2>
<p>L‚Äôajout de m√©thodes √† une classe suit le m√™me sch√©ma que le
constructeur. Ainsi pour avoir une m√©thode <code>conjugate</code> qui
retourne le conjug√©e d‚Äôune instance de nombre complexe, on peut
faire</p>
<pre class="python"><code>class Complex:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag
    def conjugate(self):
        return Complex(self.real, -self.imag)</code></pre>
<p>Avec</p>
<pre class="python"><code>&gt;&gt;&gt; z = Complex(0.5, 1.5)</code></pre>
<p>on a alors</p>
<pre class="python"><code>&gt;&gt;&gt; w = Complex.conjugate(z)
&gt;&gt;&gt; w.real
0.5
&gt;&gt;&gt; w.imag
1.5</code></pre>
<p>ou bien, puisque Python prend en charge automatiquement la cr√©ation
de m√©thodes li√©es aux instances</p>
<pre class="python"><code>&gt;&gt;&gt; w = z.conjugate()
&gt;&gt;&gt; w.real
0.5
&gt;&gt;&gt; w.imag
1.5</code></pre>
<h2 id="m√©thodes-magiques-1">M√©thodes magiques</h2>
<p>Il est un peu frustrant de ne pas voir les nombres complexes
s‚Äôafficher proprement dans le terminal √† ce stade :</p>
<pre class="python"><code>&gt;&gt;&gt; Complex(0.5, 1.5) # doctest: +ELLIPSIS
&lt;__main__.Complex object at 0x...&gt;</code></pre>
<p>C‚Äôest un probl√®me que nous pouvons r√©soudre en d√©finissant une
m√©thode magique <code>__repr__</code>, charg√©e de construire une
repr√©sentation adapt√©e des instances sous forme de cha√Æne de
caract√®res.</p>
<pre class="python"><code>class Complex:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag
    def conjugate(self):
        return Complex(self.real, -self.imag)
    def __repr__(self):
        # ‚ö†Ô∏è weird output when self.imag &lt; 0
        return f"({self.real}+{self.imag}j")</code></pre>
<p>On a alors une repr√©sentation compatible avec la notation lit√©rale
des nombres complexes int√©gr√©s</p>
<pre class="python"><code>&gt;&gt;&gt; Complex(0.5, 1.5)
(0.5+1.5j)</code></pre>
<p>Le support des op√©rations arithm√©tiques est similaire. Pour disposer
de l‚Äôaddition par exemple, on peut faire :</p>
<pre class="python"><code>class Complex:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag
    def conjugate(self):
        return Complex(self.real, -self.imag)
    def __repr__(self):
        # ‚ö†Ô∏è weird output when self.imag &lt; 0
        return f"({self.real}+{self.imag}j")
    def __add__(w, z):
        return Complex(w.real+z.real, w.imag+z.imag)</code></pre>
<p>et alors</p>
<pre class="python"><code>&gt;&gt;&gt; z = Complex(0.5, 1.5)
&gt;&gt;&gt; z + z.conjugate()
(1+0j)</code></pre>
<p>A noter que pour ce type de m√©thodes, qui accepte deux instances de
la classe en argument, l‚Äôusage est d‚Äôutiliser les noms <code>self</code>
et <code>other</code> et donc de pr√©f√©rer la d√©finition suivante
(√©quivalente) :</p>
<pre class="python"><code>class Complex:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag
    def conjugate(self):
        return Complex(self.real, -self.imag)
    def __repr__(self):
        # ‚ö†Ô∏è weird output when self.imag &lt; 0
        return f"({self.real}+{self.imag}j)"
    def __add__(self, other):
        return Complex(
            self.real + other.real, 
            self.imag + other.imag
        )</code></pre>
<h2 id="attributs-priv√©s">Attributs priv√©s</h2>
<p>Tous les attributs d‚Äôun objet n‚Äôont pas n√©cessairement vocation √†
√™tre <strong>publics</strong> ; on peut vouloir des donn√©es
<strong>priv√©es</strong>, √† usage interne, uniquement exploitable par
les m√©thodes propres √† un objet. La convention en Python est de pr√©fixer
le nom de tels attributs par un unique caract√®re de soulignement.</p>
<p>Il est possible ensuite de contr√¥ler au cas par cas la fa√ßon dont on
autorise le monde ext√©rieur √† interager avec ces donn√©es. Par exemple,
nous pouvons faire en sorte que notre nombre complexe s‚Äôassure que ses
parties r√©elles et imaginaires soient des nombres flottants. A ce stade
aucune s√©curit√© de ce type n‚Äôest pr√©sente ; il est donc tr√®s facile (y
compris par accident) de cr√©er des ‚Äúnombres complexes‚Äù invalides qui
seront sans doute la source de bugs futurs ‚Ä¶</p>
<pre class="python"><code>&gt;&gt;&gt; Complex("Hello", "world!")
(Hello+world!j)</code></pre>
<p>Mais nous pouvons heureusement remplacer les attributs publics
<code>real</code> et <code>imag</code> par des attributs priv√©s
<code>_real</code> et <code>_imag</code> et exposer de fa√ßon contr√¥l√©e
ces valeurs en lecture et/ou en √©criture par le biais de m√©thodes
d√©di√©es : des <strong>accesseurs</strong> (<strong>getters</strong>
et/ou <strong>setters</strong>).</p>
<p>Par exemple, nous pouvons faire en sorte que lorsque l‚Äôon souhaite
fixer la valeur de la partie r√©elle ou imaginaire, on s‚Äôassure au
pr√©alable d‚Äôavoir bien affaire √† un nombre flottant, o√π l‚Äôon g√©n√®re
imm√©diatemment une erreur circonstanci√©e. Nous pouvons m√™me adapter le
constructeur pour qu‚Äôil b√©n√©ficie de cette s√©curit√© suppl√©mentaire. Bien
s√ªr comme nous avons rendus priv√©s les parties r√©elles et imaginaires,
il nous faudra fournir des fonctions d‚Äôacc√®s en lecture pour que les
utilisateurs externes des nombres complexes puissent les exploiter. En
interne, il faudra adapter les m√©thodes pour qu‚Äôelles exploient les
attributs priv√©s ou les accesseurs, plut√¥t que les attributs publics qui
ont √©t√© supprim√©s.</p>
<pre class="python"><code>class Complex:
    def __init__(self, real, imag):
        self.set_real(real)
        self.set_imag(imag)
    def get_real(self):
        return self._real
    def set_real(self, real):
        if isinstance(real, float):
            self._real = real
        else:
            raise TypeError(f"{real!r} is not a float")
    def get_imag(self):
        return self._imag
    def set_imag(self, imag):
        if isinstance(imag, float):
            self._imag = imag
        else:
            raise TypeError(f"{imag!r} is not a float")
    def conjugate(self):
        return Complex(self._real, -self._imag)
    def __repr__(self):
        # ‚ö†Ô∏è weird output when self.imag &lt; 0
        return f"({self._real}+{self._imag}j)"
    def __add__(self, other):
        return Complex(
            self._real + other._real, 
            self._imag + other._imag
        )</code></pre>
<p>Les nombres complexes se comportent alors conform√©ment √† nos
attentes.</p>
<pre class="python"><code>&gt;&gt;&gt; z = Complex(0.5, 1.5)
&gt;&gt;&gt; z
(0.5+1.5j)
&gt;&gt;&gt; z.get_real()
0.5
&gt;&gt;&gt; z.set_real(-0.5)
&gt;&gt;&gt; z
(-0.5+1.5j)
&gt;&gt;&gt; z.set_real("Hello")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 11, in set_real
TypeError: 'Hello' is not a float</code></pre>
<details>
<summary>
<h4 id="acc√®s-√†-lattribut-priv√©-ou-accesseur">Acc√®s √† l‚Äôattribut priv√©
ou accesseur ?</h4>
</summary>
<p>Vous noterez que dans une m√©thode de la classes <code>Complex</code>,
on a parfaitement le droit de faire appel aux attributs priv√©s</p>
<pre class="python"><code>def conjugate(self):
    return Complex(self._real, -self._imag)</code></pre>
<p>Dans ce cas pr√©cis, cela n‚Äô√©tait toutefois pas indispensable ;
l‚Äôinterface publique des nombres complexes √©tait suffisamment riche et
nous aurions pu utiliser les getters pour impl√©menter la m√™me
fonctionnalit√©.</p>
<pre class="python"><code>def conjugate(self):
    return Complex(self.get_real(), -self.get_imag())</code></pre>
<p>Il est probable que cela aurait √©t√© pr√©f√©rable. Certes l‚Äôappel √†
<code>conjugate</code> est un peu moins performant dans le second cas
(un appel de fonction de plus est n√©cessaire), mais cela n‚Äôest
probablement pas critique. Mais en contrepartie, si nous utilisons les
accesseurs et que nous d√©cidons ult√©rieurement de changer
l‚Äôimpl√©mentation interne de la classe ‚Äì par exemple de remplacer les
attributs <code>_real</code> et <code>_imag</code> par un nombre
complexe int√©gr√© <code>_complex</code> ‚Äì en pr√©servant son interface
publique, il ne sera pas n√©cessaire de changer l‚Äôimpl√©mentation de ces
m√©thodes.</p>
</details>
<h2 id="propri√©t√©s">Propri√©t√©s</h2>
<p>On pourra regretter la lourdeur syntaxique des accesseurs par rapport
√† l‚Äôacc√®s √† des attributs publiques. Heureusement il existe un m√©canisme
qui offre la m√™me interface syntaxique que l‚Äôacc√®s √† des attributs, mais
la m√™me s√©curit√© que le passage par des accesseurs : les
<strong>propri√©t√©s</strong>. Ce sont des attributs ‚Äúvirtuels‚Äù que l‚Äôon
d√©finit par leur getter et/ou leur setter. Ainsi, si l‚Äôon rajoute les
propri√©t√©s <code>real</code> et <code>imag</code> √† notre impl√©mentation
de la classe <code>Complex</code>,</p>
<pre class="python"><code>class Complex:
    def __init__(self, real, imag):
        self.set_real(real)
        self.set_imag(imag)
    def get_real(self):
        return self._real
    def set_real(self, real):
        if isinstance(real, float):
            self._real = real
        else:
            raise TypeError(f"{real!r} is not a float")
    real = property(get_real, set_real)
    def get_imag(self):
        return self._imag
    def set_imag(self, imag):
        if isinstance(imag, float):
            self._imag = imag
        else:
            raise TypeError(f"{imag!r} is not a float")
    imag = property(get_imag, set_imag)
    def conjugate(self):
        return Complex(self._real, -self._imag)
    def __repr__(self):
        # ‚ö†Ô∏è weird output when self.imag &lt; 0
        return f"({self._real}+{self._imag}j)"
    def __add__(self, other):
        return Complex(
            self._real + other._real, 
            self._imag + other._imag
        )</code></pre>
<p>on r√©cup√®re l‚Äôusage simplifi√© de l‚Äôacc√®s aux parties r√©elles et
imaginaires, mais sans avoir perdu la s√©curit√© de la v√©rification du
type des attributs <code>real</code> et <code>imag</code>.</p>
<pre class="python"><code>&gt;&gt;&gt; z = Complex(0.5, 1.5)
&gt;&gt;&gt; z
(0.5+1.5j)
&gt;&gt;&gt; z.real
0.5
&gt;&gt;&gt; z.real = -0.5
&gt;&gt;&gt; z
(-0.5+1.5j)
&gt;&gt;&gt; z.real = "Hello"
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 11, in set_real
TypeError: 'Hello' is not a float</code></pre>
<h1 id="objectification-examples">Objectification (Examples)</h1>
<pre><code>class Snake:
    def __init__(self, geometry, direction):
        self.geometry = geometry
        self.direction = direction
    def __iter__(self):
        return iter(self.geometry)
    def __len__(self):
        return len(self.geometry)
    def __getitem__(self, index):
        return self.geometry[index]
    def __eq__(self, other):
        return (isinstance(other, Snake) and self.geometry == other.geometry and self.direction == other.direction)
    

geometry = [(10, 15), (11, 15), (12, 15)]
direction = (0, 1)
snake = Snake(geometry, direction)

snake

for (x, y) in snake:
    print(x, y)

(10, 15) in snake

len(snake)

snake[0]

geometry = [(10, 15), (11, 15), (12, 15)]
direction = (0, 1)
snake == Snake(geometry, direction)

fruit = (10, 10)

_state = None

class GameState:
    def __init__(self, snake, fruit):
        self.snake = snake
        self.fruit = fruit
        
    def save(self):
        global _state
        _state = (self.snake, self.fruit)
        
    def load(): # does not depend on self
        snake = _state[0]
        fruit = _state[1]
        return GameState(snake, fruit)
    
    load = staticmethod(load)

_state = None

class GameState:
    def __init__(self, snake, fruit):
        self.snake = snake
        self.fruit = fruit
        
    def save(self):
        global _state
        _state = (self.snake, self.fruit)

    @staticmethod # decorator ; equivalent to load = staticmethod(load)
    def load(): # does not depend on self
        snake = _state[0]
        fruit = _state[1]
        return GameState(snake, fruit)

state = GameState(snake, fruit)

state.fruit = (12, 12)

_state

state.save()

_state

state.fruit = (0, 0)

state2 = state.load()

state = GameState.load()

state.fruit

H√©ritage

_state = None

class GameState2: # sans h√©ritage
    def __init__(self, snake, fruit, score):
        self.snake = snake
        self.fruit = fruit
        self.score = score
        
    def save(self):
        global _state
        _state = (self.snake, self.fruit, self.score)

    @staticmethod # decorator ; equivalent to load = staticmethod(load)
    def load(): # does not depend on self
        snake = _state[0]
        fruit = _state[1]
        score = _state[2]
        return GameState2(snake, fruit, score)
    

class GameState2(GameState): # avec h√©ritage: GameState2 d√©rive de GameState
    def __init__(self, snake, fruit, score):
        super().__init__(snake, fruit) # stocke snake et fruit en attributs
        self.score = score
    def save(self):
        global _state
        super().save() # _state == (snake, fruit)
        #state_list = list(_state)
        #state_list.append(self.score)
        #_state = tuple(state_list)
        # shorter:
        _state = _state + (self.score,)
    @staticmethod # decorator ; equivalent to load = staticmethod(load)
    def load(): # does not depend on self
        state1 = GameState.load()
        snake = state1.snake
        fruit = state1.fruit
        score = _state[2]
        return GameState2(snake, fruit, score)

score = 12
state = GameState2(snake, fruit, score)

state.snake, state.fruit, state.score

state.save()

_state

state2 = GameState2.load()

state2.snake

state2.fruit

state2.score

Accesseurs, Variables priv√©es, etc.

import copy

class Snake:
    def __init__(self, geometry, direction):
        self._geometry = geometry
        self._direction = direction
    def get_geometry(self):
        print("GET")
        return copy.copy(self._geometry)
    def set_geometry(self, geometry):
        print("SET")
        # TODO: ajout validation de geometry
        self._geometry = copy.copy(geometry)
    geometry = property(get_geometry, set_geometry)    
        
    def get_score(self):
        return len(self)
    score = property(get_score) # read-only, virtual property
    
        
    def __iter__(self):
        return iter(self.geometry)
    def __len__(self):
        return len(self.geometry)
    def __getitem__(self, index):
        return self.geometry[index]
    def __eq__(self, other):
        return (isinstance(other, Snake) and self.geometry == other.geometry and self.direction == other.direction)
    
class GameState:
    def __init__(self, snake, fruit):
        self.snake = snake
        self.fruit = fruit

geometry = [(10, 15), (11, 15), (12, 15)]
direction = (0, 1)
snake = Snake(geometry, direction)

snake._geometry # √ßa marche mais _ indique que par convention, seules les m√©thodes Snake devraient acc√©der √† cet attribut
# attribut priv√©

snake.get_geometry()

geometry = snake.get_geometry()

geometry[0] = None # pas de corruption de la variable snake._geometry grace √† la copie !!!

snake.get_geometry()

snake.set_geometry([(0, 0), (0, 1)])

snake.get_geometry()

snake.geometry = [(3, 3)]

snake.geometry

snake.score

snake.score = 999

---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
/tmp/ipykernel_34619/2459733161.py in &lt;module&gt;
----&gt; 1 snake.score = 999

AttributeError: can't set attribute

help(copy)</code></pre>
</body>
</html>
