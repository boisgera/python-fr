<!DOCTYPE html>

<html lang="fr" xml:lang="fr" xmlns="http://www.w3.org/1999/xhtml">
<head>
<script>
        window.MathJax = {
          tex: {
            tags: 'ams'
          }
        };
       </script>

<meta charset="utf-8"/>
<meta content="pandoc" name="generator"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport"/>
<meta content="SÃ©bastien BoisgÃ©rault, MINES Paris, UniversitÃ© PSL" name="author"/>
<title>Fonctions</title>
<style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
<link href="css/style.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&amp;display=swap" rel="stylesheet"/>
<script>

      function filterConsole(text) {
          let lines = text.split("\n");

          console.log(lines);

          let pythonConsole = lines && lines[0].startsWith(">>>");
          if (!pythonConsole) {
              return text + "\n\n";
          } else {
              let newLines = [];
              for (let line of lines) {
                  if (line.startsWith(">>> ") || line.startsWith("... ")) {
                      newLines.push(line.slice(4));
                  } else if (line.startsWith("...")){
                      newLines.push(line.slice(3));
                  }

              }
              return newLines.join("\n") + "\n";
          }

      }

      document.addEventListener("DOMContentLoaded", (event) => {
          let codeBlocks = document.querySelectorAll("pre.python")
          for (let codeBlock of codeBlocks) {

              let button = document.createElement("button")
              let icon = document.createElement("img");
              button.appendChild(icon)
              codeBlock.insertBefore(button, codeBlock.firstChild);

              icon.setAttribute("src", "icons/copy.svg");
              icon.setAttribute("style", "opacity: 0.5;")
              button.addEventListener('click', (event) => {
                  let text = button.nextElementSibling.textContent;
                  text = filterConsole(text);
                  navigator.clipboard.writeText(text);
              });

              codeBlock.setAttribute("style", "position: relative");
              button.setAttribute("style", 
              "position: absolute; right: 1em; top: 1em; opacity: 0.0;");

              codeBlock.addEventListener("mouseover", (event) => {
                  button.style.setProperty("transition", "opacity 0.1s ease-out");
                  button.style.setProperty("opacity", "1.0");
              });

              codeBlock.addEventListener("mouseout", (event) => {
                  button.style.setProperty("transition", "opacity 0.75s ease-out");
                  button.style.setProperty("opacity", "0.0");
              });

              button.addEventListener("mouseover", (event) => {
                  icon.style.setProperty("transition", "opacity 0.1s ease-out");
                  icon.style.setProperty("opacity", "0.75");
              })

              button.addEventListener("mouseout", (event) => {
                  icon.style.setProperty("transition", "opacity 0.75s ease-out");
                  icon.style.setProperty("opacity", "0.5");
              })


          }
      });    
  </script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
<!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Fonctions</h1>
<p class="author"><a href="mailto:Sebastien.Boisgerault@minesparis.psl.eu">SÃ©bastien
BoisgÃ©rault</a>, MINES Paris, UniversitÃ© PSL</p>
<p class="date">Lundi 17 octobre 2022</p>

<p>
<span style="display:inline-block;width:1em;position:relative;margin-right:0.25em">
<img height="auto" src="icons/github.svg" style="position:relative;top:0.15em;" width="100%"/>
</span>
<a href="https://github.com/boisgera/python-fr">
          https://github.com/boisgera/python-fr
        </a>
</p>

<p>
<span style="display:inline-block;width:1em;position:relative;margin-right:0.25em">
<img height="auto" src="icons/git.svg" style="position:relative;top:0.15em;" width="100%"/>
</span>
<a href="https://github.com/boisgera/python-fr/commit/9b33100">
          #9b33100
        </a>
</p>
</header>
<details>
<summary>
<h2>Table des matiÃ¨res</h2>
</summary>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#fonctions" id="toc-fonctions">Fonctions</a></li>
<li><a href="#invocables" id="toc-invocables">Invocables</a></li>
<li><a href="#fonctions-gÃ©nÃ©ratrices" id="toc-fonctions-gÃ©nÃ©ratrices">Fonctions gÃ©nÃ©ratrices</a></li>
<li><a href="#programmation-fonctionnelle" id="toc-programmation-fonctionnelle">Programmation
fonctionnelle</a></li>
</ul>
</nav></details>


<h2 id="fonctions">Fonctions</h2>
<h3 id="gÃ©nÃ©ralitÃ©s">GÃ©nÃ©ralitÃ©s</h3>
<p>Les fonctions sont dÃ©finies au moyen du mot-clÃ© <code>def</code>,
suivi du nom de la fonction, suivi de la liste de leurs
<strong>paramÃ¨tres</strong> entre parenthÃ¨ses. La <strong>valeur de
retour</strong> dâ€™une fonction est prÃ©cÃ©dÃ©e du mot-clÃ©
<code>return</code>.</p>
<pre class="python"><code>def fibonacci(n):
    "Return a list of n Fibonacci numbers."
    result = []
    a, b = (0, 1)
    while len(result) &lt; n:
        result.append(a)
        a, b = b, a+b
    return result</code></pre>
<p>Pour appeler la fonction <code>fibonacci</code> en lui passant comme
paramÃ¨tre lâ€™<strong>argument</strong> <code>10</code> et rÃ©cupÃ©rer le
rÃ©sultat :</p>
<pre class="python"><code>&gt;&gt;&gt; numbers = fibonacci(10)
&gt;&gt;&gt; numbers
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</code></pre>
<p>Les paramÃ¨tres dâ€™une fonction peuvent Ãªtre accompagnÃ© dâ€™une
<strong>valeur par dÃ©faut</strong>. On peut ainsi rajouter un second
paramÃ¨tre <code>start</code> Ã  la fonction <code>fibonacci</code> et lui
associer la valeur par dÃ©faut <code>(0, 1)</code>.</p>
<pre class="python"><code>def fibonacci(n, start=(0, 1)):
    "Return a list of n Fibonacci numbers."
    result = []
    a, b = start
    while len(result) &lt; n:
        result.append(a)
        a, b = b, a+b
    return result</code></pre>
<p>Si lâ€™on ne spÃ©cifie pas la valeur du paramÃ¨tre Ã  lâ€™invocation, sa
valeur par dÃ©faut est alors utilisÃ©e. Dans le cas prÃ©sent, cela signifie
que si lâ€™on ne donne pas de second argument Ã  la fonction
<code>fibonacci</code>, elle se comporte comme la premiÃ¨re version :</p>
<pre class="python"><code>&gt;&gt;&gt; numbers = fibonacci(10)
&gt;&gt;&gt; numbers
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</code></pre>
<p>Par contre, si lâ€™on fournit un second argument, la valeur par dÃ©faut
nâ€™est pas utilisÃ©e.</p>
<pre class="python"><code>&gt;&gt;&gt; numbers = fibonacci(10, (21, 34))
&gt;&gt;&gt; numbers
[21, 34, 55, 89, 144, 233, 377, 610, 987, 1597]</code></pre>
<p>Notons que les arguments peuvent en gÃ©nÃ©ral Ãªtre
<strong>positionnels</strong> (ğŸ‡ºğŸ‡¸ : <strong>positional
arguments</strong>) â€“ le paramÃ¨tre auquel lâ€™argument est affectÃ© dÃ©pend
de la position de lâ€™argument dans la liste des arguments passÃ©s Ã  la
fonction â€“ oÃ¹ <strong>nommÃ©s</strong> (ğŸ‡ºğŸ‡¸ : <strong>keyword
arguments</strong>), auquel cas lâ€™argument est affectÃ© au paramÃ¨tre du
mÃªme nom.</p>
<p>Les arguments nommÃ©s sont souvent pratiques pour rendre le rÃ´le de
lâ€™argument plus clair. Ainsi ici le second argument de
<code>fibonacci</code>, nommÃ© <code>start</code>, est une paire
dâ€™entiers qui fournit les deux valeurs initiales de la suite de
Fibonacci. Le rÃ´le du code est sans doute plus Ã©vident si lâ€™on utilise
un argument nommÃ© :</p>
<pre class="python"><code>&gt;&gt;&gt; numbers = fibonacci(10, start=(21, 34))
&gt;&gt;&gt; numbers
[21, 34, 55, 89, 144, 233, 377, 610, 987, 1597]</code></pre>
<p>Notons que lâ€™utilisation dâ€™arguments nommÃ©s permet aussi de
sâ€™affranchir de lâ€™ordre dans lesquels les paramÃ¨tres de la fonction sont
spÃ©cificiÃ©s :</p>
<pre class="python"><code>&gt;&gt;&gt; numbers = fibonacci(start=(21, 34), n=10)
&gt;&gt;&gt; numbers
[21, 34, 55, 89, 144, 233, 377, 610, 987, 1597]</code></pre>
<h3 id="arguments-et">Arguments : <code>*</code> et <code>**</code></h3>
<p>Il est possible de stocker des valeurs dans un n-uplet<a class="footnote-ref" href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>,
puis de les utiliser comme arguments positionnels dans lâ€™appel Ã  une
fonction. Par exemple :</p>
<pre class="python"><code>&gt;&gt;&gt; args = (10, (21, 34))
&gt;&gt;&gt; fibonacci(*args)
[21, 34, 55, 89, 144, 233, 377, 610, 987, 1597]</code></pre>
<p>Un mÃ©canisme similaire existe avec les dictionnaires et les arguments
nommÃ©s :</p>
<pre class="python"><code>&gt;&gt;&gt; kwargs = {"n": 10, "start": (21, 34)}
&gt;&gt;&gt; fibonacci(**kwargs)
[21, 34, 55, 89, 144, 233, 377, 610, 987, 1597]</code></pre>
<p>Il est possible dâ€™hybrider les deux approches :</p>
<pre class="python"><code>&gt;&gt;&gt; args = (10,)
&gt;&gt;&gt; kwargs = {"start": (21, 34)}
&gt;&gt;&gt; fibonacci(*args, **kwargs)
[21, 34, 55, 89, 144, 233, 377, 610, 987, 1597]</code></pre>
<p>Il y a Ã©galement une forme de symÃ©trie dans ce mÃ©canisme, qui peut
Ãªtre utilisÃ© pour dÃ©finir une fonction admettant un nombre arbitraire
dâ€™arguments positionnels et/ou nommÃ©s. Par exemple, avec :</p>
<pre class="python"><code>def f(*args, **kwargs):
    print(f"args = {args!r}")
    print(f"kwargs = {kwargs!r}")</code></pre>
<p>on obtient :</p>
<pre class="python"><code>&gt;&gt;&gt; f(1, "Hello!")
args = (1, 'Hello!')
kwargs = {}
&gt;&gt;&gt; f(fast=True, verbose=False)
args = ()
kwargs = {'fast': True, 'verbose': False}</code></pre>
<h3 id="typage-statique">Typage statique</h3>
<p>Python est un langage typÃ© dynamiquement ; la mÃªme variable peut
dÃ©signer un entier Ã  un moment et une chaÃ®ne de caractÃ¨res Ã  un autre.
NÃ©anmoins, il est possible â€“ mais câ€™est optionnel â€“ dâ€™attacher
statiquement Ã  une variable une <a href="https://docs.python.org/fr/3/library/typing.html"><strong>annotation
de type</strong></a> (ğŸ‡ºğŸ‡¸ : <strong>type hint</strong>).</p>
<p>Par exemple, si vous voulez dÃ©clarer que la fonction
<code>fibonacci</code> prend comme argument un entier et une paire
dâ€™entiers et renvoie une liste dâ€™entiers, vous pouvez la dÃ©finir de la
faÃ§on suivante :</p>
<pre class="python"><code>def fibonacci(
    n: int, 
    start: tuple[int, int] = (0, 1)
) -&gt; list[int]:
    "Return a list of n Fibonacci numbers."
    result : list[int] = []
    a, b = start
    while len(result) &lt; n:
        result.append(a)
        a, b = b, a+b
    return result</code></pre>
<p>Cette information peut Ãªtre utilisÃ©e pendant le dÃ©veloppement pour
dÃ©tecter dâ€™Ã©ventuelles incohÃ©rences structurelles de votre code. Ainsi,
si vous complÃ©tez le code ci-dessus par :</p>
<pre class="python"><code>fibonacci("Hello!", True)</code></pre>
<p>lâ€™utilisation de <a href="http://mypy-lang.org/">mypy</a> vous
fournira :</p>
<pre class="bash"><code>$ mypy fib.py
fibonacci.py:13: error: Argument 1 to "fibonacci" has incompatible type "str"; expected "int"
fibonacci.py:13: error: Argument 2 to "fibonacci" has incompatible type "bool"; expected "Tuple[int, int]"
Found 2 errors in 1 file (checked 1 source file)</code></pre>
<h3 id="espaces-de-noms">Espaces de noms</h3>
<p>La <a href="https://fr.wikipedia.org/wiki/Port%C3%A9e_(informatique)"><strong>portÃ©e</strong></a>
(ğŸ‡ºğŸ‡¸ : <strong>scope</strong>) dâ€™une variable au sein dâ€™un programme
dÃ©termine la maniÃ¨re dont elle est associÃ© Ã  une valeur. Au niveau
supÃ©rieur (dâ€™un fichier, dâ€™un module, de lâ€™interprÃ©teur Python, etc.),
les variables sont <strong>globales</strong>. Le lien entre le nom de la
variable et la valeur quâ€™elle dÃ©signe est dÃ©crit par le dictionnaire
<code>globals()</code> : câ€™est lâ€™<strong>espace de nom</strong> (ğŸ‡ºğŸ‡¸ :
<strong>namespace</strong>) associÃ© aux variables globales.</p>
<pre class="python"><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; message = "Hello world"
&gt;&gt;&gt; def answer():
...    return 42
...
&gt;&gt;&gt; globs = globals()
&gt;&gt;&gt; globs["math"] is math
True
&gt;&gt;&gt; globs["message"] is message
True
&gt;&gt;&gt; globs["answer"] is answer
True</code></pre>
<p>Au sein des fonctions, il y a en gÃ©nÃ©ral des variables
<strong>locales</strong> Ã  la fonction. Câ€™est en particulier le cas des
paramÃ¨tres de la fonction, et â€“ en lâ€™absence dâ€™instruction contraire â€“
des variables qui y sont assignÃ©es. Dans le corps de cette fonction,
lâ€™espace de noms associÃ© peut Ãªtre obtenu en invoquant
<code>locals()</code>.</p>
<pre class="python"><code>&gt;&gt;&gt; x = 1
&gt;&gt;&gt; def f(y):
...     z = 3
...     locs = locals()
...     print("x" in locs)
...     print("y" in locs)
...     print("z" in locs)
... 
&gt;&gt;&gt; f(2)
False
True
True</code></pre>
<p>Il est donc possible pour une variable locale de cacher (ğŸ‡ºğŸ‡¸ :
<strong>shadow</strong>) une variable globale :</p>
<pre class="python"><code>&gt;&gt;&gt; a = 1
&gt;&gt;&gt; def f():
...     a = 2  # assigned =&gt; local
...     print(a)
...
&gt;&gt;&gt; a
1
&gt;&gt;&gt; f()
2
&gt;&gt;&gt; a  # in the global scope =&gt; the value remains unchanged
1</code></pre>
<p>En lâ€™absence dâ€™une telle affectation, au sein dâ€™une fonction, les
variables globales restent accessibles, mais donc en lecture seule :</p>
<pre class="python"><code>&gt;&gt;&gt; a = 1
&gt;&gt;&gt; def f():
...     print(a)
...
&gt;&gt;&gt; f()
1</code></pre>
<p>Si lâ€™on souhaite affecter une nouvelle valeur Ã  une variable globale
dans le corps dâ€™une fonction, il est nÃ©cessaire dâ€™y dÃ©clarer la variable
comme globale :</p>
<pre class="python"><code>&gt;&gt;&gt; a = 1
&gt;&gt;&gt; def f():
...     global a
...     a = 2
...
&gt;&gt;&gt; print(a)
1
&gt;&gt;&gt; f()
&gt;&gt;&gt; print(a)
2</code></pre>
<p>Il existe Ã©galement une portÃ©e <strong>intÃ©grÃ©e</strong> (ğŸ‡ºğŸ‡¸ :
<strong>built-in</strong>) et en cas de fonctions
<strong>emboitÃ©es</strong> (ğŸ‡ºğŸ‡¸ : <strong>nested</strong>), le concept de
portÃ©e externe ; cf par exemple <a href="https://realpython.com/python-scope-legb-rule/">la description de
la rÃ¨gle LEGB</a>.</p>
<h2 id="invocables">Invocables</h2>
<p>On qualifie dâ€™<strong>invocable</strong> (ou
<strong>appelable</strong> ; ğŸ‡ºğŸ‡¸ : <strong>callable</strong>) tout objet
se comportant comme une fonction, câ€™est-Ã -dire pouvant Ãªtre appelÃ©
(invoquÃ©) avec la mÃªme syntaxe que les fonctions.</p>
<p>Ainsi, lâ€™entier <code>0</code> nâ€™est pas invocable :</p>
<pre class="python"><code>&gt;&gt;&gt; zero = 0
&gt;&gt;&gt; zero()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'int' object is not callable</code></pre>
<p>mais la fonction sans argument qui renvoie <code>0</code> est
invocable :</p>
<pre class="python"><code>&gt;&gt;&gt; def zero_fun():
...     return 0
...
&gt;&gt;&gt; zero_fun()
0</code></pre>
<p>ce qui nâ€™est pas une surprise puisque câ€™est une fonction !</p>
<pre class="python"><code>&gt;&gt;&gt; type(zero_fun)
&lt;class 'function'&gt;
&gt;&gt;&gt; import types
&gt;&gt;&gt; isinstance(zero_fun, types.FunctionType)
True</code></pre>
<p>Lâ€™invocabilitÃ© des objets Python peut Ãªtre testÃ©e avec la fonction
<code>callable</code> :</p>
<pre class="python"><code>&gt;&gt;&gt; callable(zero)
False
&gt;&gt;&gt; callable(zero_fun)
True</code></pre>
<p>Notons que ce test permet de dire si un objet est invocable, mais pas
si on peut lâ€™invoquer sans arguments (ni combien dâ€™arguments sont
nÃ©cessaires, de quel type, etc.). Ainsi :</p>
<pre class="python"><code>&gt;&gt;&gt; callable(hash)
True</code></pre>
<p>Mais :</p>
<pre class="python"><code>&gt;&gt;&gt; hash()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: hash() takes exactly one argument (0 given)</code></pre>
<p>Toutefois :</p>
<pre class="python"><code>&gt;&gt;&gt; hash(2**100)
549755813888</code></pre>
<p>Pour en savoir plus sur les arguments attendus, il faudra se reporter
Ã  la documentation de lâ€™objet considÃ©rÃ©.</p>
<h3 id="types">Types</h3>
<p>Un objet comme <code>int</code> est Ã©galement invocable :</p>
<pre class="python"><code>&gt;&gt;&gt; callable(int)
True</code></pre>
<p>ce que lâ€™on peut rapidement confirmer expÃ©rimentalement :</p>
<pre class="python"><code>&gt;&gt;&gt; int()
0
&gt;&gt;&gt; int(0.0)
0
&gt;&gt;&gt; int("0")
0</code></pre>
<p>Pourtant, ce nâ€™est pas une function, mais un type :</p>
<pre class="python"><code>&gt;&gt;&gt; type(int)
&lt;class 'type'&gt;
&gt;&gt;&gt; type(int) is type  # ğŸ¤¯
True
&gt;&gt;&gt; isinstance(int, types.FunctionType)
False</code></pre>
<p>Rappelons que les types (ou classes) ont vocation, quand on les
appelle, Ã  crÃ©er des instances du type considÃ©rÃ© :</p>
<pre class="python"><code>&gt;&gt;&gt; isinstance(int(), int)
True
&gt;&gt;&gt; isinstance(int(0.0), int)
True
&gt;&gt;&gt; isinstance(int("0"), int)
True</code></pre>
<p>Les classes que vous dÃ©finissez sont Ã©galement invocables :</p>
<pre class="python"><code>class Transmogrifier:
    pass</code></pre>
<pre class="python"><code>&gt;&gt;&gt; callable(Transmogrifier)
True
&gt;&gt;&gt; transmogrifier = Transmogrifier()
&gt;&gt;&gt; isinstance(transmogrifier, Transmogrifier)
True</code></pre>
<h3 id="mÃ©thodes">MÃ©thodes</h3>
<p>Un <a href="https://calvinandhobbes.fandom.com/wiki/Transmogrifier">transmogrifieur</a>
peut transformer son utilisateur en ce quâ€™il souhaite (par dÃ©faut, un
tigre ğŸ¯ ; mais on nâ€™a pas spÃ©cifiÃ© la taille du tigre ! ğŸ˜‰).</p>
<figure>
<img alt="Calvin (Ã  droite) transformÃ© en tigre" src="https://www.nicepng.com/png/full/198-1980373_calvin-and-hobbes-png-hd-calvin-and-hobbes.png"/>
<figcaption aria-hidden="true"><a href="https://calvinandhobbes.fandom.com/wiki/Calvin_in_Tiger_Form_(Transmogrifier_alter_ego)">Calvin
(Ã  droite) transformÃ© en tigre</a></figcaption>
</figure>
<pre class="python"><code>class Transmogrifier:
    def __init__(self, turn_into="tiger"):
        self.turn_into = turn_into
    def activate(self, user):
        return self.turn_into</code></pre>
<pre class="python"><code>&gt;&gt;&gt; transmogrifier = Transmogrifier()
&gt;&gt;&gt; transmogrifier.activate("calvin")
'tiger'</code></pre>
<p>Lâ€™opÃ©ration <code>transmogrifier.activate("calvin")</code> nâ€™est pas
â€œatomiqueâ€ : elle consiste dâ€™abord Ã  obtenir lâ€™attribut
<code>activate</code> de lâ€™objet <code>transmogrifier</code>, puis Ã 
lâ€™invoquer avec lâ€™argument <code>"calvin"</code>.</p>
<pre class="python"><code>&gt;&gt;&gt; transmogrify = transmogrifier.activate
&gt;&gt;&gt; callable(transmogrify)
True
&gt;&gt;&gt; transmogrify("calvin")
'tiger'</code></pre>
<p>Cela est possible car <code>activate</code> est une mÃ©thode (liÃ©e Ã 
lâ€™instance <code>transmogrifier</code> de <code>Transmogrifier</code>)
et est donc invocable.</p>
<pre class="python"><code>&gt;&gt;&gt; transmogrify
&lt;bound method Transmogrifier.activate ...&gt;
&gt;&gt;&gt; type(transmogrify)
&lt;class 'method'&gt;
&gt;&gt;&gt; import types
&gt;&gt;&gt; type(transmogrify) is types.MethodType
True</code></pre>
<h3 id="instances">Instances</h3>
<p>Notons quâ€™Ã  ce stade <code>Transmogrifier</code> est invocable et la
mÃ©thode <code>activate</code> des transmogrifieurs Ã©galement. Mais les
transmogrifieurs eux-mÃªmes ne le sont pas :</p>
<pre class="python"><code>&gt;&gt;&gt; callable(transmogrifier)
False</code></pre>
<p>Si nous estimons que câ€™est prÃ©fÃ©rable, nous pouvons faire en sorte
quâ€™ils le deviennent. Il semble assez raisonnable de faire en sorte
quâ€™invoquer un transmogrifieur lâ€™active :</p>
<pre class="python"><code>class Transmogrifier:
    def __init__(self, turn_into="tiger"):
        self.turn_into = turn_into
    def activate(self, user):
        return self.turn_into
    def __call__(self, user):
        return self.activate(user)</code></pre>
<pre class="python"><code>&gt;&gt;&gt; transmogrifier = Transmogrifier()
&gt;&gt;&gt; callable(transmogrifier)
True</code></pre>
<p>Nous pouvons alors simplifier lâ€™usage du transmogrifieur de la faÃ§on
suivante :</p>
<pre class="python"><code>&gt;&gt;&gt; transmogrifier("calvin")
'tiger'</code></pre>
<h2 id="fonctions-gÃ©nÃ©ratrices">Fonctions gÃ©nÃ©ratrices</h2>
<p>Une fonction est <strong>gÃ©nÃ©ratrice</strong> si sa dÃ©finition
utilise le mot-clÃ© <code>yield</code>.</p>
<ul>
<li><p>Appeler une fonction gÃ©nÃ©ratrice nâ€™exÃ©cute pas son code
immÃ©diatement, mais fournit comme valeur de retour un
itÃ©rateur.</p></li>
<li><p>AccÃ©der au premier Ã©lÃ©ment de cet itÃ©rateur exÃ©cute la fonction
jusquâ€™Ã  atteindre le premier <code>yield</code> ; la fonction renvoie
alors la valeur fournie au <code>yield</code>, puis pause son
exÃ©cution.</p></li>
<li><p>AccÃ©der au second Ã©lÃ©ment de cet itÃ©rateur reprend le fil de
lâ€™exÃ©cution Ã  ce point, jusquâ€™Ã  atteindre le second <code>yield</code>,
etc.</p></li>
</ul>
<p>Ainsi, avec</p>
<pre class="python"><code>def one_two_three():
    yield 1
    yield 2
    yield 3</code></pre>
<p>on obtient</p>
<pre class="python"><code>&gt;&gt;&gt; for i in one_two_three():
...     print(i)
...
1
2
3</code></pre>
<p>et</p>
<pre class="python"><code>&gt;&gt;&gt; list(one_two_three())
[1, 2, 3]</code></pre>
<h4 id="exemples-source-itertools">Exemples (source: <a href="https://docs.python.org/3/library/itertools.html#module-itertools">itertools</a>)</h4>
<pre class="python"><code>def count(start=0, step=1):
    """
    Generate the sequence start, start + step, start + 2*step, ...
    """
    value = start
    while True:
        yield value
        value += step</code></pre>
<p>Usage :</p>
<pre class="python"><code>&gt;&gt;&gt; odd_numbers = count(start=1, step=2)
&gt;&gt;&gt; for number in odd_numbers:
...     if number &gt;= 20:
...         break
...     else:
...         print(number)
...
1 
3 
5 
7 
9 
11 
13 
15 
17 
19</code></pre>
<hr/>
<pre class="python"><code>def cycle(iterable):
    """
    Yield all items from an iterable, then repeat this sequence indefinitely. 
    """
    items = list(iterable)
    while items:
        for item in items:
            yield item</code></pre>
<p>Usage :</p>
<pre class="python"><code>&gt;&gt;&gt; for i, item in enumerate(cycle("ABCD")):
...     if i &gt;= 12:
...         break
...     else:
...         print(item)
...
A 
B 
C 
D 
A 
B 
C 
D 
A 
B 
C 
D</code></pre>
<hr/>
<pre class="python"><code>def repeat(object, n=None):
    """
    Yield object an object n times (or indefinitely if n is None).
    """
    if n is None:
        while True:
            yield object
    else:
        for i in range(n):
            yield object</code></pre>
<p>Usage :</p>
<pre class="python"><code>&gt;&gt;&gt; list(repeat(10, 3))
[10, 10, 10]</code></pre>
<h4 id="exercices">Exercices</h4>
<ul>
<li><p>ImplÃ©mentez votre propre version des fonctions standards
<code>range</code>, <code>enumerate</code> et <code>zip</code> en
utilisant les fonctions gÃ©nÃ©ratrices.</p></li>
<li><p>Revoyez la dÃ©finition de la fonction <code>fibonacci</code> pour
en faire une fonction gÃ©nÃ©ratrice, qui renvoie les nombres de Fibonacci
sous forme dâ€™itÃ©rateur plutÃ´t que de liste. Faites en sorte que lorsque
lâ€™argument <code>n</code> nâ€™est pas fourni, lâ€™itÃ©rateur parcoure
lâ€™intÃ©gralitÃ© de la suite.</p></li>
</ul>
<h2 id="programmation-fonctionnelle">Programmation fonctionnelle</h2>
<p>Un des traits de la <a href="https://fr.wikipedia.org/wiki/Programmation_fonctionnelle"><strong>programmation
fonctionelle</strong></a>, un style de programmation que supporte (en
partie) Python, est de permettre de manipuler les fonctions comme des
objets comme les autres, pouvant Ãªtre dÃ©signÃ©s par des variables,
stockÃ©s dans des conteneurs, passÃ©s comme arguments Ã  dâ€™autres
fonctions, etc. Une fonction acceptant comme argument des fonctions
et/ou en renvoyant est une <strong>fonction dâ€™ordre supÃ©rieur</strong>
(ğŸ‡ºğŸ‡¸ : <strong>higher-order function</strong>).</p>
<p>Les librairies mathÃ©matiques exploitent souvent avec profit ces
fonctions dâ€™ordre supÃ©rieures. Ainsi, la librairie de diffÃ©rentiation
automatique <a href="https://github.com/HIPS/autograd#autograd---">Autograd</a> dÃ©finit
une fonction dâ€™ordre supÃ©rieur <code>grad</code> qui associe Ã  une
fonction dâ€™un argument rÃ©el sa dÃ©rivÃ©e.</p>
<p>Sa documentation donne lâ€™exemple suivant dâ€™usage :</p>
<pre class="python"><code>&gt;&gt;&gt; import autograd.numpy as np 
&gt;&gt;&gt; from autograd import grad   
&gt;&gt;&gt; def tanh(x):                
...     y = np.exp(-2.0 * x)
...     return (1.0 - y) / (1.0 + y)
...
&gt;&gt;&gt; d_tanh = grad(tanh)  # d_tanh is the derivative of tanh   
&gt;&gt;&gt; d_tanh(1.0)          # we evaluate it at x = 1.0              
0.419974341614026</code></pre>
<p>Un autre usage important des fonctions dâ€™ordre supÃ©rieur est
lâ€™exploitation de <strong>fonctions de rappels</strong> (ğŸ‡ºğŸ‡¸ :
<strong>callbacks</strong>), notamment dans les interfaces
graphiques.</p>
<p>Par exemple, regardons comment est programmÃ©e lâ€™application graphique
donnÃ©e comme example dans <a href="http://tkdocs.com/tutorial/firstexample.html#design">le tutoriel
de la bibliothÃ¨que Tk</a> :</p>
<figure>
<img alt="Convertisseur de pieds en mÃ¨tres" src="images/converter.png"/>
<figcaption aria-hidden="true">Convertisseur de pieds en
mÃ¨tres</figcaption>
</figure>
<p>Lâ€™interface graphique est en partie dÃ©finie par le code :</p>
<pre class="python"><code>from tkinter import *
from tkinter import ttk

root = Tk()
root.title("Feet to Meters")

mainframe = ttk.Frame(root, padding="3 3 12 12")
mainframe.grid(column=0, row=0, sticky=(N, W, E, S))
root.columnconfigure(0, weight=1)
root.rowconfigure(0, weight=1)

feet = StringVar()
feet_entry = ttk.Entry(mainframe, width=7, textvariable=feet)
feet_entry.grid(column=2, row=1, sticky=(W, E))

meters = StringVar()
ttk.Label(mainframe, textvariable=meters).grid(column=2, row=2, sticky=(W, E))</code></pre>
<p>Retenons simplement Ã  ce stade que <code>root</code> est la fenÃªtre
principale de lâ€™application, <code>feet</code> le champ de texte oÃ¹ nous
rentrons la valeur de la longueur en pieds et <code>meters</code> le
champ de texte qui devra afficher la longueur Ã©quivalent en mÃ¨tres
lorsque lâ€™on cliquesur le bouton.</p>
<p>Pour que lâ€™application se comporte comme voulu, nous dÃ©finissons une
fonction <code>calculate</code> qui a chaque fois quâ€™elle est invoquÃ©e,
lit la longueur en pied et Ã©crit la longeur en mÃ¨tres :</p>
<pre class="python"><code>def calculate(*args):
    try:
        value = float(feet.get())
        meters_value = int(0.3048 * value * 1e4 + 0.5) / 1e4
        meters.set(meters_value)
    except ValueError:
        pass</code></pre>
<p>Puis nous crÃ©ons un bouton qui <strong>rappelle</strong> cette
fonction (de rappel) Ã  chaque fois quâ€™il est pressÃ© :</p>
<pre class="python"><code>ttk.Button(
    mainframe, 
    text="Calculate", 
    command=calculate
).grid(column=3, row=3, sticky=W)</code></pre>
<p>Quelques labels de plus dans lâ€™interface graphique, un peu de
positionnement, et nous sommes práº¿ts Ã  lancer la boucle dâ€™exÃ©cution du
code !</p>
<pre class="python"><code>ttk.Label(mainframe, text="feet").grid(column=3, row=1, sticky=W)
ttk.Label(mainframe, text="is equivalent to").grid(column=1, row=2, sticky=E)
ttk.Label(mainframe, text="meters").grid(column=3, row=2, sticky=W)

for child in mainframe.winfo_children(): 
    child.grid_configure(padx=5, pady=5)

feet_entry.focus()

root.mainloop()</code></pre>
<h3 id="lambda">Lambda</h3>
<p>Les <strong>fonctions lambda</strong> en Python sont une construction
qui nâ€™augmente pas lâ€™expressivitÃ© du langage â€“ on ne peut rien faire
avec des fonctions lambda quâ€™on ne pouvait dÃ©jÃ  faire avec les fonctions
classiques â€“ mais permet dans certains cas dâ€™obtenir un code plus
concis.</p>
<p>Ainsi, pour trouver numÃ©riquement le zÃ©ro de la fonction <span class="math inline">\(x \mapsto x^2 - 2\)</span> entre <span class="math inline">\(0\)</span> et <span class="math inline">\(2\)</span> avec <code>scipy</code>, aprÃ¨s avoir
importÃ© une fonction de recherche de racines :</p>
<pre class="python"><code>from scipy.optimize import root_scalar as find_root</code></pre>
<p>on peut dÃ©finir la fonction qui nous intÃ©resse, ce qui suppose de la
nommer (par exemple <code>f</code>) :</p>
<pre class="python"><code>def f(x):
    return x*x - 2</code></pre>
<p>puis appeler la routine de recherche de zÃ©ros de <code>scipy</code>
:</p>
<pre class="python"><code>&gt;&gt;&gt; find_root(f, bracket=[0, 2])
      converged: True
           flag: 'converged'
 function_calls: 9
     iterations: 8
           root: 1.4142135623731364</code></pre>
<p>Mais on peut aussi passer lâ€™Ã©tape prÃ©alable de dÃ©finition et de
nommage de la function, et faire cet opÃ©ration Ã  la volÃ©e, dans lâ€™appel
Ã  <code>find_root</code>, au moyen dâ€™une fonction lambda :</p>
<pre class="python"><code>&gt;&gt;&gt; find_root(lambda x: x*x-2, bracket=[0, 2])
      converged: True
           flag: 'converged'
 function_calls: 9
     iterations: 8
           root: 1.4142135623731364</code></pre>
<p>Le mot-clÃ© <code>lambda</code> fait rÃ©fÃ©rence Ã  la notation
traditionnelle du <a href="https://fr.wikipedia.org/wiki/Lambda-calcul"><span class="math inline">\(\lambda\)</span>-calcul</a> ; on y dÃ©signerait la
fonction <span class="math inline">\(x \mapsto x^2+1\)</span> par la
notation <span class="math inline">\((\lambda x.x^2+1)\)</span>.</p>
<h3 id="fermetures">Fermetures</h3>
<p>Ainsi parlait WikipÃ©dia :</p>
<blockquote>
<p>Dans un langage de programmation, une <strong>fermeture</strong> ou
<strong>clÃ´ture</strong> (ğŸ‡ºğŸ‡¸ : <strong>closure</strong>) est une
fonction accompagnÃ©e de son environnement lexical.</p>
<p>Lâ€™<strong>environnement lexical</strong> dâ€™une fonction est
lâ€™ensemble des variables non locales quâ€™elle a capturÃ©es, soit par
valeur (câ€™est-Ã -dire par copie des valeurs des variables), soit par
rÃ©fÃ©rence (câ€™est-Ã -dire par copie des adresses mÃ©moires des
variables).</p>
<p>Une fermeture est donc crÃ©Ã©e, entre autres, lorsquâ€™une fonction est
dÃ©finie dans le corps dâ€™une autre fonction et utilise des paramÃ¨tres ou
des variables locales de cette derniÃ¨re.</p>
<p>Source : <a href="https://fr.wikipedia.org/wiki/Fermeture_(informatique)"><img src="icons/Wikipedia.svg" style="height: 1em; display: inline; vertical-align: -0.175em;"/>
Fermeture (informatique)</a></p>
</blockquote>
<p>Essayons de donner un exemple concret illustrant cette
dÃ©finition.</p>
<h4 id="evaluateur-dexpression">Evaluateur dâ€™expression</h4>
<p>La fonction intÃ©grÃ©e <code>eval</code> permet de calculer la valeur
dâ€™expressions reprÃ©sentÃ©es par des chaÃ®nes de caractÃ¨res. Ainsi :</p>
<pre class="python"><code>&gt;&gt;&gt; x = 1 
&gt;&gt;&gt; y = 2
&gt;&gt;&gt; eval("x + y")
3</code></pre>
<p>Il est Ã©galement possible dâ€™ignorer lâ€™espace de nom global et de
spÃ©cifier explicitement lâ€™espace de nom que devra utiliser lâ€™Ã©valuateur
:</p>
<pre class="python"><code>&gt;&gt;&gt; namespace = {"x": 3, "y": 4}
&gt;&gt;&gt; eval("x + y", namespace)
7</code></pre>
<p>Nous aimerions disposer dâ€™une fonction dâ€™ordre supÃ©rieur â€“ disons
<code>fun</code> â€“ qui associe Ã  une expression, comme
<code>"x+y"</code>, une fonction qui acceptera les arguments nommÃ©s
nÃ©cessaires pour Ã©valer lâ€™expression â€“ ici <code>x</code> et
<code>y</code> â€“ et renverra la valeur associÃ©e de lâ€™expression.</p>
<p>Avec les fermetures de fonctions, rien de plus simple :</p>
<pre class="python"><code>def fun(expression):
    def f(**kwargs): 
       return eval(expression, kwargs)
    return f</code></pre>
<p>On remarquera que <code>eval(expression, kwargs)</code> utilise la
variable <code>kwargs</code> qui est locale Ã  <code>f</code> (car passÃ©e
en paramÃ¨tre). Mais elle utilise Ã©galement <code>expression</code> qui
est une variable locale de <code>fun</code> ; elle appartient Ã 
lâ€™environnement lexical de <code>f</code> qui est donc une
fermeture.</p>
<p>VoilÃ  comment utiliser notre fonction <code>fun</code> :</p>
<pre class="python"><code>&gt;&gt;&gt; add_xy = fun("x + y")
&gt;&gt;&gt; add_xy(x=4, y=5)
9</code></pre>
<hr/>
<p>Les variables non-locales dâ€™une fermeture sont accessibles en lecture
seule par dÃ©faut. Pour les modifier, il faut au prÃ©alable les dÃ©clarer
explicitement comme non-locales Ã  la fermeture. (La situation est donc
similaire celle des variables globales exploitÃ©es dans les
fonctions.)</p>
<p>Par exemple, la fonction <code>make_get_set</code> gÃ©nÃ¨re deux
fermetures qui accÃ¨dent Ã  la mÃªme variable <code>x</code> (qui est
locale Ã  <code>make_get_set</code>) : <code>get</code> permet de lire la
valeur de <code>x</code> et nâ€™a donc pas besoin de la dÃ©clarer comme
non-locale ; mais <code>set</code> doit permettre de changer la valeur
de cette variable et la dÃ©clare donc comme non-locale :</p>
<pre class="python"><code>def make_get_set(x):
     def get():
         return x
     def set(value):
         nonlocal x
         x = value
     return get, set</code></pre>
<p>Exemple dâ€™usage de ces fonctions :</p>
<pre class="python"><code>&gt;&gt;&gt; get, set = make_get_set(1)
&gt;&gt;&gt; get()
1
&gt;&gt;&gt; set(5)
&gt;&gt;&gt; get()
5</code></pre>
<hr/>
<p>Il est bon de savoir que les variables non-locales sont capturÃ©es par
rÃ©fÃ©rence en Python, et non par valeur, ce qui peut dans certains cas
rendre votre vie â€¦ intÃ©ressante ! ğŸ˜‚</p>
<p>Par exemple, le programmeur ayant Ã©crit :</p>
<pre class="python"><code>def make_actions():
    actions = []
    for i in range(3):
        def printer():
            print(i)
        actions.append(printer)
    return actions</code></pre>
<p>sâ€™attend probablement Ã  gÃ©nÃ©rer une liste de 3 actions qui
afficheront respectivement 0, 1 et 2 lorsquâ€™elles seront appelÃ©es. Mais
comme le <code>i</code> utilisÃ© par la fonction <code>printer</code> est
capturÃ© par rÃ©fÃ©rence, sa valeur effective est dÃ©terminÃ©e uniquement au
moment de lâ€™appel <code>print(i)</code>. Hors Ã  ce moment-lÃ , la boucle
<code>for</code> a dÃ©jÃ  Ã©tÃ© exÃ©cutÃ©e, donc <code>i</code> vaut
<code>2</code>. Par consÃ©quent, on obtient en fait :</p>
<pre class="python"><code>&gt;&gt;&gt; for action in make_actions():
...     action()
...
2
2
2</code></pre>
<p>Le â€œhackâ€ classique pour rÃ©soudre ce problÃ¨me consiste Ã  utiliser le
fait que les arguments par dÃ©faut dâ€™une fonction sont Ã©valuÃ©s lors de sa
dÃ©finition. Par consÃ©quent, si lâ€™on dÃ©finit :</p>
<pre class="python"><code>def make_actions():
    actions = []
    for i in range(3):
        def printer(i=i):
            print(i)
        actions.append(printer)
    return actions</code></pre>
<p>on obtient comme souhaitÃ© :</p>
<pre class="python"><code>&gt;&gt;&gt; for action in make_actions():
...     action()
...
0
1
2</code></pre>
<h3 id="dÃ©corateurs">DÃ©corateurs</h3>
<p>Les <strong>dÃ©corateurs</strong> sont un â€œsucre syntaxiqueâ€ utilisant
le symbole <code>@</code> et facilitant la mise en dâ€™oeuvre dâ€™un schÃ©ma
assez courant que nous allons illustrer sur un exemple.</p>
<p>Imaginons que nous ayons dÃ©veloppÃ© une fonction
<code>plus_one</code></p>
<pre class="python"><code>def plus_one(x):
    return x + 1</code></pre>
<p>mais quâ€™en la testant dans un programme, nous trouvons son
comportement mystÃ©rieux. Pour comprendre ce qui se passe, nous modifions
sa dÃ©finition pour afficher ses arguments et les valeurs quâ€™elle renvoie
Ã  chaque fois quâ€™elle est appelÃ©e.</p>
<pre class="python"><code>def plus_one(x):
    print("input:", x)
    y = x + 1
    print("output:", y)
    return y</code></pre>
<p>avec la ferme intention de retirer ce code supplÃ©mentaire une fois le
mystÃ¨re Ã©clairci.</p>
<p>Ce procÃ©dÃ© nâ€™est toutefois pas trÃ¨s satisfaisant. PlutÃ´t que de
modifier le code de <code>plus_one</code>, nous pouvons dÃ©velopper une
fonction <code>debug</code> qui prendra la fonction
<code>plus_one</code> comme argument et renverra une nouvelle fonction
qui fonctionne comme <code>plus_one</code> Ã  ceci prÃ¨s quâ€™elle affiche
les arguments et la valeur de sortie :</p>
<pre class="python"><code>def debug(f):
    def f_debug(x):
        print("input:", x)
        y = f(x)
        print("output:", y)
        return y
    return f_debug</code></pre>
<p>Pour tester le code en situation rÃ©elle, il nous suffit alors de
remplacer la fonction <code>plus_one</code> classique par cette nouvelle
fonction</p>
<pre class="python"><code>plus_one = debug(plus_one)</code></pre>
<p>puis dâ€™effacer uniquement cette ligne supplÃ©mentaire une fois le
mystÃ¨re Ã©clairci.</p>
<p>Il sâ€™avÃ¨re que le code</p>
<pre class="python"><code>def plus_one(x):
    return x + 1

plus_one = debug(plus_one)</code></pre>
<p>est Ã©quivalent Ã  la construction suivante utilisant le dÃ©corateur
<code>@debug</code> :</p>
<pre class="python"><code>@debug
def plus_one(x):
    return x + 1</code></pre>
<p>On pourra trouver cette seconde notation plus agrÃ©able et lisible
!</p>
<h4 id="exemple">Exemple</h4>
<p>La fonction dâ€™ordre supÃ©rieur <code>count</code> ci-dessous peut Ãªtre
utilisÃ©e sous forme de dÃ©corateur pour enregistrer le nombre de fois oÃ¹
une fonction a Ã©tÃ© invoquÃ©e (le nombre dâ€™appels de la fonction est
stockÃ© dans lâ€™attribut <code>count</code> de la fonction) :</p>
<pre class="python"><code>def count(f):
    def counted_f(x):
        counted_f.count += 1
        return f(x)
    counted_f.count = 0
    return counted_f</code></pre>
<p>Par exemple, si lâ€™on recherche Ã  localiser la racine positive de la
fonction <span class="math inline">\(x \mapsto x^2 - 2\)</span>, qui est
<span class="math inline">\(\sqrt{2}\)</span>, on peut la dÃ©finir en la
dÃ©corant avec <code>@count</code> :</p>
<pre class="python"><code>@count
def f(x):
    return x*x - 2</code></pre>
<p>Puis procÃ©der par itÃ©rations successives pour produire une estimation
de <span class="math inline">\(\sqrt{2}\)</span> :</p>
<pre class="python"><code>&gt;&gt;&gt; f(0)
-2
&gt;&gt;&gt; f(1)
-1
&gt;&gt;&gt; f(2)
2
&gt;&gt;&gt; f(1.5)
0.25
&gt;&gt;&gt; f(1.4)
-0.04000000000000026
&gt;&gt;&gt; f(1.45)
0.10250000000000004
&gt;&gt;&gt; f(1.43)
0.04489999999999972
&gt;&gt;&gt; f(1.42)
0.01639999999999997
&gt;&gt;&gt; f(1.41)
-0.011900000000000244</code></pre>
<p>Et constater Ã  posteriori combien dâ€™appels de la fonction
<code>f</code> ont Ã©tÃ© nÃ©cessaires :</p>
<pre class="python"><code>&gt;&gt;&gt; f.count
9</code></pre>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr/>
<ol>
<li id="fn1" role="doc-endnote"><p>ou plus gÃ©nÃ©ralement un objet
itÃ©rable.<a class="footnote-back" href="#fnref1" role="doc-backlink">â†©ï¸</a></p></li>
</ol>
</section>
</body>
</html>
