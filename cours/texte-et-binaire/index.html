<!DOCTYPE html>

<html lang="fr" xml:lang="fr" xmlns="http://www.w3.org/1999/xhtml">
<head>
<script>
        window.MathJax = {
          tex: {
            tags: 'ams'
          }
        };
       </script>

<meta charset="utf-8"/>
<meta content="pandoc" name="generator"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport"/>
<meta content="SÃ©bastien BoisgÃ©rault" name="author"/>
<title>Texte, binaire et fichiers</title>
<style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
<link href="css/style.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&amp;display=swap" rel="stylesheet"/>
<script>

      function filterConsole(text) {
          let lines = text.split("\n");

          console.log(lines);

          let pythonConsole = lines && lines[0].startsWith(">>>");
          if (!pythonConsole) {
              return text + "\n\n";
          } else {
              let newLines = [];
              for (let line of lines) {
                  if (line.startsWith(">>> ") || line.startsWith("... ")) {
                      newLines.push(line.slice(4));
                  } else if (line.startsWith("...")){
                      newLines.push(line.slice(3));
                  }

              }
              return newLines.join("\n") + "\n";
          }

      }

      document.addEventListener("DOMContentLoaded", (event) => {
          let codeBlocks = document.querySelectorAll("pre.python")
          for (let codeBlock of codeBlocks) {

              let button = document.createElement("button")
              let icon = document.createElement("img");
              button.appendChild(icon)
              codeBlock.insertBefore(button, codeBlock.firstChild);

              icon.setAttribute("src", "icons/copy.svg");
              icon.setAttribute("style", "opacity: 0.5;")
              button.addEventListener('click', (event) => {
                  let text = button.nextElementSibling.textContent;
                  text = filterConsole(text);
                  navigator.clipboard.writeText(text);
              });

              codeBlock.setAttribute("style", "position: relative");
              button.setAttribute("style", 
              "position: absolute; right: 1em; top: 1em; opacity: 0.0;");

              codeBlock.addEventListener("mouseover", (event) => {
                  button.style.setProperty("transition", "opacity 0.1s ease-out");
                  button.style.setProperty("opacity", "1.0");
              });

              codeBlock.addEventListener("mouseout", (event) => {
                  button.style.setProperty("transition", "opacity 0.75s ease-out");
                  button.style.setProperty("opacity", "0.0");
              });

              button.addEventListener("mouseover", (event) => {
                  icon.style.setProperty("transition", "opacity 0.1s ease-out");
                  icon.style.setProperty("opacity", "0.75");
              })

              button.addEventListener("mouseout", (event) => {
                  icon.style.setProperty("transition", "opacity 0.75s ease-out");
                  icon.style.setProperty("opacity", "0.5");
              })


          }
      });    
  </script>
<!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Texte, binaire et fichiers</h1>
<p class="author"><a href="mailto:Sebastien.Boisgerault@mines-paristech.fr">SÃ©bastien
BoisgÃ©rault</a></p>
<p class="date">Friday 25 august 2023</p>

<p>
<span style="display:inline-block;width:1em;position:relative;margin-right:0.25em">
<img height="auto" src="icons/github.svg" style="position:relative;top:0.15em;" width="100%"/>
</span>
<a href="https://github.com/boisgera/python-fr">
          https://github.com/boisgera/python-fr
        </a>
</p>

<p>
<span style="display:inline-block;width:1em;position:relative;margin-right:0.25em">
<img height="auto" src="icons/git.svg" style="position:relative;top:0.15em;" width="100%"/>
</span>
<a href="https://github.com/boisgera/python-fr/commit/7da617f">
          #7da617f
        </a>
</p>
</header>
<details>
<summary>
<h2>Table des matiÃ¨res</h2>
</summary>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#chaÃ®nes-de-caractÃ¨res" id="toc-chaÃ®nes-de-caractÃ¨res">ChaÃ®nes de caractÃ¨res</a></li>
<li><a href="#donnÃ©es-binaires" id="toc-donnÃ©es-binaires">DonnÃ©es
binaires</a></li>
<li><a href="#encodage-de-texte" id="toc-encodage-de-texte">Encodage de
texte</a></li>
<li><a href="#fichiers" id="toc-fichiers">Fichiers</a></li>
</ul>
</nav></details>


<h2 id="chaÃ®nes-de-caractÃ¨res">ChaÃ®nes de caractÃ¨res</h2>
<p>Les chaÃ®nes de caractÃ¨res Python sont dÃ©finies comme des suites de
caractÃ¨res <a href="https://fr.wikipedia.org/wiki/Unicode">Unicode</a>
dÃ©limitÃ©s par les caractÃ¨res <code>'</code> ou <code>"</code>.</p>
<pre class="python"><code>&gt;&gt;&gt; s = "Hello world! ğŸ‘‹"
&gt;&gt;&gt; s
'Hello world! ğŸ‘‹'</code></pre>
<p>Le choix de la ğŸ‡ºğŸ‡¸ <strong>simple quote</strong> ou de la ğŸ‡ºğŸ‡¸
<strong>double quote</strong> est la plupart du temps indiffÃ©rent.
PrÃ©fÃ©rez la double quote quand votre texte comporte des simples quotes
(ou apostrophes) et rÃ©ciproquement :</p>
<pre class="python"><code>&gt;&gt;&gt; 'Je n'ai pas compris!'
  File "&lt;stdin&gt;", line 1
    'Je n'ai pas compris!'
          ^
SyntaxError: invalid syntax
&gt;&gt;&gt; "J'ai compris!"
"J'ai compris!"
</code></pre>
<p>Les caractÃ¨res prÃ©cÃ©dÃ©s dâ€™un slash (<code>\</code>) sont interprÃ©tÃ©s
comme des <strong>sÃ©quences dâ€™Ã©chappement</strong> (ğŸ‡ºğŸ‡¸ <strong>escape
sequences</strong>) et non pas litÃ©ralement. Ainsi <code>"\n"</code> est
un retour Ã  la ligne, <code>"\t"</code> une tabulation</p>
<pre class="python"><code>&gt;&gt;&gt; print("a\nb")
a
b
&gt;&gt;&gt; print("a\tb")
a   b</code></pre>
<p><code>\\</code> un slash (et oui !), <code>\'</code> une simple quote
et <code>\"</code> une double quote,</p>
<pre class="python"><code>&gt;&gt;&gt; print("\\")
\
&gt;&gt;&gt; print('J\'ai compris!')
J'ai compris!</code></pre>
<p>etc.</p>
<p>Un caractÃ¨re Unicode est caractÃ©risÃ© par un ğŸ‡ºğŸ‡¸ <a href="https://en.wikipedia.org/wiki/Code_point"><strong>code
point</strong></a>, un entier le plus souvent reprÃ©sentÃ© sous la forme
â€œU+????????â€ oÃ¹ les <code>?</code> sont des caractÃ¨res hÃ©cadÃ©cimaux ; ce
qui se traduit en Python par <code>\U????????</code>. Par exemple :</p>
<pre class="python"><code>&gt;&gt;&gt; ord("a")
97
&gt;&gt;&gt; hex(97)
'0x61'
&gt;&gt;&gt; "\U00000061"
'a'</code></pre>
<p>Lorsquâ€™il suffit de quatre ou deux caractÃ¨res hexadÃ©cimaux pour
dÃ©crire le code point, on peut utiliser les syntaxes <code>\u????</code>
ou <code>\x??</code> qui sont plus compactes</p>
<pre class="python"><code>&gt;&gt;&gt; "\u0061"
'a'
&gt;&gt;&gt; "\x61"
'a'</code></pre>
<p>Les Ã©mojis par exemple nÃ©cessitent la syntaxe la plus longue :</p>
<pre><code>&gt;&gt;&gt; "smiley: \U0001f600"
'smiley: ğŸ˜€'
&gt;&gt;&gt; 
&gt;&gt;&gt; "pile of poo: \U0001f4a9"
'pile of poo: ğŸ’©'</code></pre>
<p>Le chaÃ®nes de caractÃ¨res se comportement Ã©galement comme des
collections (immuables) de caractÃ¨res â€¦ mÃªme sâ€™il nâ€™existe pas de type
â€œcaractÃ¨reâ€ ! (Un â€œcaractÃ¨reâ€ est en fait reprÃ©sentÃ© comme une chaÃ®ne de
caractÃ¨res de longueur 1.)</p>
<pre class="python"><code>&gt;&gt;&gt; s = "Hello world! ğŸ‘‹"
&gt;&gt;&gt; len(s)
14
&gt;&gt;&gt; s[0]
'H'
&gt;&gt;&gt; s[-1]
'ğŸ‘‹'
&gt;&gt;&gt; s[0:5]
'Hello'
&gt;&gt;&gt; s[:5] + s[5:]
'Hello world! ğŸ‘‹'
&gt;&gt;&gt; for c in s:
...     print(c) 
... 
H
e
l
l
o
 
w
o
r
l
d
!
 
ğŸ‘‹
&gt;&gt;&gt; list(s)
['H', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '!', ' ', 'ğŸ‘‹']</code></pre>
<p>Les <strong>f-strings</strong> permettent dâ€™insÃ©rer au sein de
chaÃ®nes de caractÃ¨res des chaÃ®nes de caractÃ¨res stockÃ©es dans des
variables</p>
<pre class="python"><code>&gt;&gt;&gt; target = "world"
&gt;&gt;&gt; emoji = "ğŸ‘‹"
&gt;&gt;&gt; f"Hello {target} {emoji}"
'Hello world ğŸ‘‹'</code></pre>
<p>ou bien des donnÃ©es qui peuvent Ãªtre reprÃ©sentÃ©es comme des chaÃ®nes
de caractÃ¨res, ou bien mÃªme des expressions qui sâ€™Ã©valuent en de tels
objets</p>
<pre class="python"><code>&gt;&gt;&gt; f"1+1 = {1+1}"
'1+1 = 2'</code></pre>
<pre class="python"><code>&gt;&gt;&gt; ok = True
&gt;&gt;&gt; f"Annie are you ok? {'yep' if ok else 'nope'}."
'Annie are you ok? yep.'
&gt;&gt;&gt; ok = False
&gt;&gt;&gt; f"Annie are you ok? {'yep' if ok else 'nope'}."
'Annie are you ok? nope.'</code></pre>
<h1 id="donnÃ©es-binaires">DonnÃ©es binaires</h1>
<p>les <strong>octets</strong> Python (ğŸ‡ºğŸ‡¸ <strong>bytes</strong>) sont
des suites de valeurs entiÃ¨res comprises entre 0 et 255 qui reprÃ©sentent
des donnÃ©es binaires arbitraires. Elle sont le plus frÃ©quemment
reprÃ©sentÃ©es sous une forme analogue aux chaÃ®nes de caractÃ¨res, mais
prÃ©fixÃ©es par un <code>b</code> :</p>
<pre class="python"><code>&gt;&gt;&gt; b"Hello world!"
b'Hello world!'</code></pre>
<p>NÃ©anmoins, seul les caractÃ¨res ASCII sont autorisÃ©s</p>
<pre class="python"><code>&gt;&gt;&gt; b"Hello world! ğŸ‘‹"
  File "&lt;stdin&gt;", line 1
SyntaxError: bytes can only contain ASCII literal characters.</code></pre>
<p>Pour dÃ©crire des octets qui ne correspondent pas Ã  des caractÃ¨res
ASCII, on peut utiliser la <strong>syntaxe dâ€™Ã©chappement</strong> (ğŸ‡ºğŸ‡¸
<strong>escape sequence</strong>) <code>\x??</code> ou les
<code>?</code> reprÃ©sentent un caractÃ¨re hexadÃ©cimal.</p>
<pre class="python"><code>&gt;&gt;&gt; b"Hello world! \xf0\x9f\x91\x8b"
b'Hello world! \xf0\x9f\x91\x8b'</code></pre>
<p>Il est aussi possible dâ€™utiliser la syntaxe dâ€™Ã©chappement Ã  la place
des caractÃ¨res ASCII</p>
<pre class="python"><code>&gt;&gt;&gt; b"\x48\x65\x6C\x6c\x6f\x20\x77\x6f\x72\x6c\x64\x21\x20\xf0\x9f\x91\x8b"
b'Hello world! \xf0\x9f\x91\x8b'</code></pre>
<p>Les octets peuvent aussi Ãªtre manipulÃ©s comme des listes (mais
immuables !) dâ€™entiers compris entre 0 et 255</p>
<pre class="python"><code>&gt;&gt;&gt; data = b"Hello world! \xf0\x9f\x91\x8b"
&gt;&gt;&gt; data[0]
72
&gt;&gt;&gt; data[0] = 100
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'bytes' object does not support item assignment
&gt;&gt;&gt; list(data)
[72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33, 32, 240, 159, 145, 139]</code></pre>
<p>Dâ€™ailleurs on peut les crÃ©er Ã  partir dâ€™une telle liste</p>
<pre class="python"><code>&gt;&gt;&gt; bytes([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33, 32, 240, 159, 145, 139])
b'Hello world! \xf0\x9f\x91\x8b'</code></pre>
<h1 id="encodage-de-texte">Encodage de texte</h1>
<p>Pour Ãªtre stockÃ© dans un fichier ou transmis sur le rÃ©seau, une
chaÃ®ne de caractÃ¨res doit Ãªtre convertie en donnÃ©es binaires. Il existe
plusieurs mÃ©thodes pour opÃ©rer cette conversion, quâ€™on appelle un
<strong>encodage</strong> (ğŸ‡ºğŸ‡¸ <strong>encoding</strong>). Lâ€™encodage
UTF-8 est un bon choix par dÃ©faut (notamment, parce quâ€™il est compatible
avec le vÃ©nÃ©rable encodage ASCII mais quâ€™il sait gÃ©rer tous les
caractÃ¨res Unicode).</p>
<pre class="python"><code>&gt;&gt;&gt; "Hello world! ğŸ‘‹".encode("utf-8")
b'Hello world! \xf0\x9f\x91\x8b'</code></pre>
<p>Il existe dâ€™autres encodages, comme UTF-16, qui produisent des
binaires diffÃ©rents.</p>
<pre class="python"><code>&gt;&gt;&gt; "Hello world! ğŸ‘‹".encode("utf-16")
b'\xff\xfeH\x00e\x00l\x00l\x00o\x00 \x00w\x00o\x00r\x00l\x00d\x00!\x00 \x00=\xd8K\xdc'</code></pre>
<p>Lâ€™opÃ©ration inverse est le <strong>dÃ©codage</strong> (ğŸ‡ºğŸ‡¸
<strong>decoding</strong>) des donnÃ©es binaires en chaÃ®nes de
caractÃ¨res</p>
<pre class="python"><code>&gt;&gt;&gt; b'Hello world! \xf0\x9f\x91\x8b'.decode("utf-8")
'Hello world! ğŸ‘‹'</code></pre>
<p>Vous noterez quâ€™il faut savoir quel encodage a Ã©tÃ© utilisÃ© pour
dÃ©coder correcter les donnÃ©es binaires. Si lâ€™on se trompe, le rÃ©sultat
peut Ãªtre dÃ©plaisant â€¦</p>
<pre class="python"><code>&gt;&gt;&gt; "SÃ©bastien".encode("utf-8").decode("cp1252")
'SÃƒÂ©bastien'</code></pre>
<p>Tous les encodages ne permettent pas de dÃ©crire tous les caractÃ¨res
du standard Unicode (mais UTF-8, UTF-16 et UTF-32 le permettent).</p>
<pre class="python"><code>&gt;&gt;&gt; "SÃ©bastien".encode("ascii")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
UnicodeEncodeError: 'ascii' codec can't encode character '\xe9' in position 1: ordinal not in range(128)
&gt;&gt;&gt; "SÃ©bastien".encode("cp1252")
b'S\xe9bastien'
&gt;&gt;&gt; "Hello world! ğŸ‘‹".encode("cp1252")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/home/boisgera/miniconda3/envs/python-fr/lib/python3.9/encodings/cp1252.py", line 12, in encode
    return codecs.charmap_encode(input,errors,encoding_table)
UnicodeEncodeError: 'charmap' codec can't encode character '\U0001f44b' in position 13: character maps to &lt;undefined&gt;</code></pre>
<h1 id="fichiers">Fichiers</h1>
<p>Pour ouvrir un fichier afin dâ€™y Ã©crire du texte, vous pouvez utiliser
le mode <code>"w"</code> (pour â€œwriteâ€)</p>
<pre class="python"><code>&gt;&gt;&gt; file = open("texte.txt", mode="w")
&gt;&gt;&gt; file.write("Hello world! ğŸ‘‹")</code></pre>
<p>mais cela nâ€™est pas nÃ©cessairement une bonne idÃ©e, car Python va
alors dÃ©cider par lui-mÃªme de lâ€™encodage utilisÃ© pour convertir votre
texte en donnÃ©es binaires. Il va pour cela utiliser lâ€™encodage dÃ©clarÃ©
par votre environnement (et encore, si tout va bien â€¦). Sur ma machine,
coup de chance, il sâ€™agit dâ€™UTF-8, et ce choix me convient</p>
<pre class="python"><code>&gt;&gt;&gt; import locale
&gt;&gt;&gt; locale.getpreferredencoding(False)
'UTF-8'</code></pre>
<p>mais rien ne dit que ce soit la mÃªme chose sur votre machine. Si nous
devons ensuite partager les fichiers texte avec dâ€™autres personne, il
faut Ãªtre en mesure de savoir comment ils sont encodÃ©s, ou mieux encore,
de choisir quel encodage est utilisÃ©. Le plus sage consiste Ã  spÃ©cifier
systÃ©matiquement et explicitement quel encodage vous souhaitez
utiliser.</p>
<pre class="python"><code>&gt;&gt;&gt; file = open("texte.txt", mode="w", encoding="utf-8")
&gt;&gt;&gt; file.write("Hello world! ğŸ‘‹")</code></pre>
<p>Et pour Ãªtre totalement explicite, nous pouvons spÃ©cifier avec
lâ€™argument <code>mode</code> que nous souhaitons ouvrir le fichier en
Ã©criture <strong>et en mode texte</strong>, en prÃ©cisant que
<code>mode="wt"</code>, au lieu de <code>mode="w"</code>. Cela ne change
rien pour lâ€™interprÃ©teur Python, mais cela simplifie la tÃ¢che des
programmeurs qui vont Ãªtre amenÃ©s Ã  relire ce code.</p>
<pre class="python"><code>&gt;&gt;&gt; file = open("texte.txt", mode="wt", encoding="utf-8")
&gt;&gt;&gt; file.write("Hello world! ğŸ‘‹")</code></pre>
<p>Câ€™est aussi une bonne habitude de fermer le fichier aprÃ¨s usage<a class="footnote-ref" href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<pre class="python"><code>&gt;&gt;&gt; file = open("texte.txt", mode="wt", encoding="utf-8")
&gt;&gt;&gt; file.write("Hello world! ğŸ‘‹")
&gt;&gt;&gt; file.close()</code></pre>
<p>Pour autant, si vous insÃ©rez du code Python entre lâ€™ouverture et la
fermeture du fichier et que ce code peut Ã©chouer (par exemple, sâ€™il nâ€™y
a plus de place sur votre disque dur pour Ã©crire
<code>"Hello world! ğŸ‘‹"</code>), lâ€™instruction de fermeture du fichier
ne sera jamais exÃ©cutÃ©e. Une version plus robuste consisterait Ã  fermer
le fichier dans tous les cas (erreur ou non), ce qui peut Ãªtre fait de
la faÃ§on suivante :</p>
<pre class="python"><code>&gt;&gt;&gt; file = open("texte.txt", mode="wt", encoding="utf-8")
&gt;&gt;&gt; try:
...     file.write("Hello world! ğŸ‘‹")
... finally:
...     file.close()
...</code></pre>
<p>â€¦ mais câ€™est un peu lourd ! Heureusement pour nous, il existe une
construction plus compacte qui offre les mÃªmes garanties :</p>
<pre class='python"wt"'><code>&gt;&gt;&gt; with open("texte.txt", mode="wt", encoding="utf-8") as file:
...     file.write("Hello world! ğŸ‘‹")
...</code></pre>
<p>Lâ€™Ã©criture dans un fichier se fait de faÃ§on analogue en remplaÃ§ant
<code>"w"</code> par <code>"r"</code> (pour â€œreadâ€) dans le
<code>mode</code> dâ€™ouverture du fichier.</p>
<pre class="python"><code>&gt;&gt;&gt; with open("texte.txt", mode="rt", encoding="utf-8") as file:
...     print(file.read())
...
Hello world! ğŸ‘‹</code></pre>
<p>Mais, si vous voulez accÃ©der Ã  des donnÃ©es qui ne sont pas du
<strong>texte en clair</strong> (ğŸ‡ºğŸ‡¸ <strong>plain text</strong>) comme
une image ou un document PDF, ou bien Ã  du texte que vous souhaitez
dÃ©coder vous-mÃªme, utilisez le mode <strong>binaire</strong> ((ğŸ‡ºğŸ‡¸
<strong>binary</strong>)) <code>"b"</code> (en lecture comme en
Ã©criture) :</p>
<pre class="python"><code>&gt;&gt;&gt; with open("texte.txt", mode="rb") as file:
...     data = file.read()
...     print(f"{type(data) = }")
...     text = data.decode("utf-8")
...     print(text)
...
type(data) = &lt;class 'bytes'&gt;
Hello world! ğŸ‘‹</code></pre>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr/>
<ol>
<li id="fn1" role="doc-endnote"><p>Il est possible que lâ€™Ã©criture dans
le fichier soit temporisÃ©e et nâ€™ait lieu quâ€™Ã  la fermeture du fichier.
Il est aussi possible que lâ€™ouverture du fichier â€œbloqueâ€ aux autres
processus lâ€™accÃ¨s au mÃªme fichier, etc.<a class="footnote-back" href="#fnref1" role="doc-backlink">â†©ï¸</a></p></li>
</ol>
</section>
</body>
</html>
